// ####################### 1교시 시작 ####################### //
※ Python 개요
	1990년 탄생
	파이썬(Python)은 1991년 프로그래머인 귀도 반 로섬(Guido van Rossum)이 발표한 고급 프로그래밍 언어로, 플랫폼 독립적이며 인터프리터식, 객체지향적, 동적 타이핑(dynamically typed) 대화형 언어이다.

	파이썬은 동적 타이핑을 지원하는 인터프리트 언어이다.

0. 왜 파이썬(Python)인가?
	- 읽기 쉽고 (구현하기도 쉽다)
	- 빠르고 (속도라는건 개발속도가 빠르다)
	- 다목적

1. 파이썬 개요 및 설치
	1.1. 파이썬 활용
		- 배우기 쉬운 교육용 프로그래밍 언어
		- 쉘 스크립트와 배치프로그램 대안
		- 데이터 과학자가 되려면 필수
		- 웹 서버 어플리케이션 - Django, Flask(프레임웍)
		- 개인과 팀 단위의 업무 자동화

	1.2. 파이썬 활용
		- 파일 및 디렉토리 정리 작업
		- 엑셀파일 및 CSV 파일 작업 자동화
		- 웹에서 데이터 가져와서(스크레이핑) 정리작업 자동화
		- 웹 서비스를 활용하여 데이터 수집 및 정리작업 자동화
		- 비정형 데이터(주로 텍스트 데이터)에서 특정 데이터 검색
		- 반복되는 메일 보내기 작업 자동화
		- 메일을 통화 업무 작업화

	1.3. 파이썬 특징
		- 가독성 (문법이 간결하고 들여쓰기를 기반으로 가독성이 좋음)
		- 풍부한 라이브러리를 바탕으로 무궁한 확장성
		- 접착성 (C로 구현된 모듈을 쉽게 만들어 붙일 수 있음, 반대 기능도 가능함)
		- 유니코드 (문자열이 모두 유니코드로 나타남)
		- 동적 타이핑 (Dynamic Language, Interpreted Language)

	1.4. 파이썬 인터프리터 설치 - www.python.org
		- 설치경로 (유닉스 계열)	-> /usr/local/bin/python3.5
		- 윈도우 -> c:\Python35 (set path=%path%;c:\pythone35)

	1.5. 파이썬 툴
		- 아톰
		- 젯브레인 (PyCharm) -> IntelliJ IDEA 만든회사
			유료인 프로페셔널 에디션과 무료인 커뮤니티 에디션이 있음 (IDE - 개발용 툴)
			  -> https://www.jetbrains.com/pycharm/download

	1.6. 파이썬 Think Point
		파이썬은 개인적 업무 자동화 용도로 사용하기 적합한 프로그래밍 언어입니다.
		반복적이고 지루한 개인업무를 파이썬으로 자동화 해봅시다.
// ####################### 1교시 종료 ####################### //


// ####################### 2교시 시작 ####################### //
※ Python 숫자다루기
	1. 숫자형 타입(Numbers)
		변수를 만들고 값을 항당
		Python Console
			a = 1
			b = 3.14
			pritn(a)
			type(b)

	2. 산술 연산
		- 덧셈
			3 + 5 => 8
		- 뺄셈
			10 - 5 => 5
		- 곱셈
			3 * 5 => 15
		- 나눗셈 (정수끼리 나눠도 실수/float 형태로 나온다)
			10 / 6 => 1.6666666666666667
		- 제곱
			2 ** 3 => 8
		- 음수
			-2 + -3 => -5

	3. 변수명
		- 변수의 타입을 지정하지 않음
		- 문자, 숫자, 밑줄(_)을 포함 가능, 숫자는 처음에 올 수 없음
		- 예약어는 변수명으로 사용할 수 없음 (아래 예약어)
			And, as, assert, break, class, continue, def, del, elif, else, except, is,
			finally, for, from global, if, import, in, lambda, nonlocal, not, or, pass, raise,
			return, try, thile, with, yield 등

		!!! PEP8 스타일 가이드를 따르자
		파이썬 개선 제안서 (Pythone Enhancement Proposal) #8
		https://www.python.org/dev/peps/pep-0008

		ex) 항공료 구하는 예제
			flight_fee = 300000	// 30만원
			num_of_adult = 2		// 성인 2명

			flight_fee * num_of_adult	// 결과

		4. 변수
			- 객체(값)를 저장하는 메모리 공간
			- 변수에 객체가 바인딩 됨
				>>> x = 100
				>>> id(x)		// 메모리 주소 나옴
					(123123121)
				>>> x = 10000
				>>> y = 10000
				>>> id(x), id(y)
					(231231231, 124141444)

		5. 파이썬에서 모든 자료 타입은 객체임 - 변수의 타입은 변하지 않음
			http://pythontutor.com (메모리상 어떻게 위치하는지 비주얼하게 보여줌)
			>>>
				a = 3
				b = 3.14
				c = a + b
				d = [1,2,3]			// 리스트
				e = {'a': 123}	// 딕셔너리

		6. 싱글 라인 주석
			# 샵 문자 이후의 모든 내용은 주석처리 되어 인터프리터에 의해 읽혀지지 않음!
			- 주석은 코드의 문서화의 의미로 코드 가독성을 향상시키고 품질과 생산성을 향상시킴
			- 주석에 대한 표준을 전체 프로젝트 표준으로 설정 필요

		7. 멀티 라인 주석 - docstring 이라고 함
			"""
				Hello, how are you?
				작성일 : 2017.11.04
				작성자 : kang.deokjoon
			"""
			- 싱글 라인 주석에 비해 여러 줄의 주석을 사용할 때 사용
			- 세개의 따옴표 사이에 들어가는 모든 문자(숫자 포함, 공백 포함)는 주석처리 됨
			- 모든 모듈, 클래스, 함수에 docstring 포함 (PEP8 스타일 가이드)
				- http://pep8.org

		8. (연습문제) 파이썬으로 계산하기
			- 여행을 떠나요 미국으로!
				문제1. 비행기 예약 - 4인가족 (성인 2명, 소아1명, 유아1명)
				문제2. 인천 - 샌프란시스코 왕복 954,200원 (유아는 10% 차지)
				문제3. 호텔 예약 (5박) - 1박에 $125.00
							(resort fee $45.00 + tax는 5.5%추가)
				문제4. 달러 환전 - 3,000불 (금일 환율 1달러에 1,147) + 은행수수료 0.45%
				문제5. 첫날 저녁 식대 - $135.52 (tax 6.75% + tip 15%)
				문제6. 주차비 - 최초 30분 $2.50 매 15분 마다 $1.25씩 추가
				문제7. 3시간 20분 주차했을 때 주차비 계산

		9. Python, java, javascript의 int형의 차이
			파이썬3에서의 int타입은 범위 제한이 없다.
			자바와 자바스크립트는 32비트 정수형을 사용한다.

		10. 학습정리
			- 정수는 int타입, 소숫점이 있는 숫자는 float타입으로 표현된다.
			- 변수는 자기 설명적으로 의미있는 단어로 작성한다.

// ####################### 2교시 종료 ####################### //

// ####################### 3교시 시작 ####################### //
※ 문자다루기
	0. 사전퀴즈
		- 숫자와 문자를 결합할 수 있다?
			숫자와 문자를 결합할 수 없다.
			int() 함수를 통해 숫자로 변환하거나 str()함수로 문자로 변환해서 결합연산을 수행한다.
		- 문자열을 나타내는 기호는 "" 와 '' 두가지 모두 사용할 수 있다?
			>>> 두가지 기호를 모두 사용해서 문자열을 나타낼 수 있으며, 주로 외따옴표(')를 사용하여 문자열을 표시한다.

	1. 문자다루기
		- 문자열 결합 : + (산술연사자중 결합연산자 역할)
		- 문자열 복제 : *
			: * 연산자를 이용하여 문자열 복제 가능
				>>> greet = 'Hello ' * 4 + '\n'
				>>> end = 'Goodbye.'
				>>> print(greet + greet + end)
		- 이스케이프 문자
			\n	개행(줄바꿈)
			\t	탭
			\r	캐리지 리턴
			\0	널(null)
			\\	문자 \
			\'	단일 인용부호
			\"	다중 인용부호
			ex)
			>>> print('\tabc')
				abc
		- 데이터 타입 변환 : str()
			str() 함수를 사용하여 데이터 타입을 문자열로 변환 가능
			> int(), float()는 마찬가지로 각각 int와 float로 변환한다.
				ex)
					>>> str(96.7)
						'96.7'
					>>> str(1.0e4)
						'10000.0'
					>>> str(True)
						'True'
		- 문자열 인덱스(오프셋)
			greeting = 'HELLO WORLD!'	// 오프셋이 단어하나씩 지정된다.

		- 문자 추출
			>>> greeting[0]
				'H'
			>>> greeting[11]
				'!'
			>>> greeting[12]
				IndexError : string index...

		- 문자열 자르기 (slicing)
			>>> mysting = 'hello world'
			>>> mystring[0:5]
				'hello'
			>>> mystring[6:11]
				'world'
			>>> mystring[6:]	// 6번째부터 마지막까지
				'world'
			>>> mystring[:5]	// 처음부터 5번째까지

			[0][1][2][3][4][5]
				시작경계는 포함되나 끝경계는 미포함되니 유의하면서 코딩필요
				>>> mystring[2:5] 이거하면 2~4까지만 나온다.

		- 문자열 자르기 : 음수 인덱스 사용
			>>> letters[-3:]		// 뒤에서 3번쨰부터 끝까지
			>>> letters[18:-3]	// 18번째 인덱스부터 뒤에서 3번째 까지
			>>> letters[-6:-3]	// 뒤에서 6번쨰부터 뒤에서 3번쨰 까지
		- 문자열 길이 : len()
			문자열의 길이를 잰다.
			다른 시퀀스 타입에서도 사용 가능하다. (시퀀스 : 순서가 있는 데이터의 모임)

	10. 연습문제
		사용자 이름을 입력받아 이메일 주소를 만들어 주는 프로그래밍
			- input() 함수 사용 : 콘솔로 부터 문장을 입력받는 함수
				순서1. 아이디를 입력하라고 메시지를 보내고 사용자 입력을 기다린다.
				순서2. 사용자가 아이디를 입력하면 아이디에 '@python_demo.co.kr' 문자열을 결합한다.
				순서3. 결합한 후 완성된 이메일 표시해준다.

	11. URF-8 문자 인코딩 방식에 대해서 알아보세요.
		UTF-8 인코딩은 유니코드 한 문자를 나타내기 위해 1바이트에서 4바이트까지를 사용한다.
		예를 들어서, U+0000부터 U+007F범위에 있는 ASCII문자들은 UTF-8에서 1바이트만으로 표시된다.
		4바이트로 표현되는 문자는 모두 기본 다국어 평면(BMP) 바깥의 유니코드 문자이며, 거의 사용되지 않는다.
		UTF-16과 UTF-8중 어느 인코딩이 더 적은 바이트를 사용하는지는 문자열에서 사용된 코드 포인트에 따라 달라지며,
		실제로 DEFLATE와 같은 일반적인 압축 알고리즘을 사용할 경우 이 차이는 무시할 수 있을 정도이다.
		이러한 압축 알고리즘을 사용하기 힘들고 크기가 중요할 경우 유니코드 표준 압축 방식
		(Standard Compression Scheme for Unicode)을 대신 사용할 수 있다.

	12. 학습정리
		- 문자열 인덱스(오프셋)를 통해 문자열 내의 각각 문자에 접근 할수 있다.
		- 시작과 끝 경계를 주어 문자열을 슬라이싱(자르기)을 할수 있다.
// ####################### 3교시 종료 ####################### //

// ####################### 4교시 시작 ####################### //
※ 리스트
	0. 파이썬에서 리스트는 원하는 모든 데이터를 담는 컨테이너
		- Read-Only 리스트 - 튜플(Tuples)
		- 위 두 가지 모두 시퀀스 구조의 컨테이너이다.
			# an empty list
			empty = []
			# list of numbers
			nums = [10, 20, 30, 40.5]
			# list of strings
			words = ['aaa', 'bbb', 'ccc']
			# list of mixed items
			anything = [10, 'aaaa', 123.45]

	1. 리스트의 아이템은 0부터 시작하는 인덱스(또는 오프셋이라고 함)로 순서를 가진다.
		- 오프셋으로 데이터를 추출 또는 변경이 가능
		- insert(offset, data) 함수를 통해 데이터 변경도 가능
		- append(data) 함수로 데이터를 마지막에 추가
		ex)
			greeting[0]
			greeting[3]
			greeting[1,4]

	2. 오프셋으로 아이템 얻기
		>>> address = ['seoul', 'seocho', 'woomyun']
		>>> address[2]
				'woomyun'
		>>> address[-1]
				'seocho'

	3. 오프셋으로 아이템 바꾸기(write)
		>>> phone_number = ['010', '1234', '5678']
		>>> phone_number[1] = '2346'
		>>> phone_number
			['010', '2346', '5678']

	4. 아이템 삭제
		- 리스트에서 아이템 삭제는 값과 인덱스 모두 가능하다.
		slang = ['aaa', 'bbb', 'ccc', 'ddd', 'eee']

		slang.remove('bbb')	// 값으로 삭제
		del slang[3]				// 인덱스로 삭제
		del slang[:2]				// 처음부터 2번째까지 삭제 (범위삭제도 가능)

	5. 슬라이스로 아이템 추출
		- 슬라이스로 리스트의 서브시퀀스를 추출할 수 있다.
			>>> address = ['seoul', 'seocho', 'woomyun']
			>>> address[0:2]
				['seoul', 'seocho']

		- 리스트 아이템 추가 : append()
			>>> address.append('123-54')
			>>> address
				['seoul', 'seocho', 'woomyun', '123-54']

		- 오프셋과 inser()로 항목 추가
			>>> address.insert(3, 'san')
			>>> address
				['seoul', 'seocho', 'woomyun', 'san', '123-54']

		- 다른 데이터 타입을 리스트로 변환 : list()
			>>> list('cat')
				['c', 'a', 't']

		- 문자열을 구분자(delimiter)로 나누어서 리스트로 변환 : split()
			>>> birthday = '1983/01/01'
			>>> birthday.split('/')
				['1983', '01', '01']

		- 값으로 오프셋 찾기 : index()
			>>> address = ['seoul', 'seocho', 'woomyun', '123-54']
			>>> address.index('seocho')
				1

		- 멤버십 확인 : in
			리스트의 멤버(아이템) 인지 확인하려면 in을 사용
				>>> address = ['seoul', 'seocho', 'woomyun', '123-54']
				>>> 'seocho' in address
					True
				>>> 'gangnam' in address
					False

		- 값 세기 : count()
			리스트에 특정 값이 얼마나 있는지 세기 위해서 count() 함수 사용
				>>> address.count('seocho')
					1
				>>> address.count('gangnam')
					0

		- 튜플 (Tuples)
			# 튜플 생성
			empty_tuple = ()
			colors = 'red', 'green', 'blue', 'yellow'	# 정의할 땐 괄호 붙이지 않음

			# 여러 변수에 값을 할당 할 수 있음
			a, b, c, d = colors	# aka 'Tuple unpacking'

			# 리스트를 튜플로 변환
			>>> lang_list = ['swift', 'javascript', 'python']
			>>> duple(lang_list)
				('swift', 'javascript', 'python')

		!!. 튜플 (Tuples)
			- 튜플은 더 적은 공간을 사용한다. (리스트보다 메모리를 적게 사용하고 속도가 빠르다)
			- 실수로 튜플의 항목이 손상될 염려가 없다.
			- 함수의 파라미터들은 튜플로 전달된다.

		10. 연습문제
			- 색상 이름을 아이템으로 가지는 리스트를 작성하세요 (색상 최소 5개 이상)
				문제1. 리스트의 아이템 개수를 출력하세요
				문제2. 리스트의 가장 마지막 아이템의 첫 번째 글자를 대문자로 변경해서 출력하세요.

		!!!
			파이썬 컬렉션에서 리스트와 딕셔너리 그리고 집합(셋)이 있습니다.
			각 데이터 타입은 약간씩 변형된 파생형 타입을 갖고 있습니다.
			사용할 데이터의 구조에 맞게 컬렉션을 사용하는 것은 중요합니다.
			파이썬은 이외에도 외부모듈 형태로 다양한 형태의 컬렉션을 지원하고 있어
			다차원의 숫자나 복잡한 구조의 데이터를 다룰때 유용하여 많은 데이터 과학자들이 파이썬을 솔루션으로 사용하고 있습니다.

		!!! 학습정리
			- 리스트와 튜플은 순서있는 데이터를 저장하는 데이터 구조이다.
			- 리스트 관련 함수를 이용해서 리스트를 조작할 수 있다.
			-튜플은 아이템 수정이 불가한 리스트이며, 속도가 빠르다.

// ####################### 4교시 종료 ####################### //





// ####################### 5교시 시작 ####################### //
※ 딕셔너리 - Dictionary - 키/값 쌍으로 데이터를 관리
	- 리스트와 유사하지만 인덱스 대신에 키를 통해 값을 찾는다.
		slang = {'cheerio':'goodby', 'knackered':'tired', 'yonks':'ages'}

	- java : 맵, 해쉬맵

	1. 딕셔너리 생성
		- 빈 딕셔너리 만들기
			slang = {}

		- 빈 딕셔너리 아이템 추가
			slang['cheerio'] = 'goobye'	// Dictionary에 키/값 쌍으로 된 아이템을 추가

		- 아이템 업데이트
			slang['smashing'] = 'awesome'

			있으면:insert, 없으면:update

		- 아이템 삭제
			del slang['cheerio']	# 키워드를 사용해서 삭제

		- 모든 항목 삭제 : clear()
			>>> slang.clear()

		- 찾고자 하는 값이 없을 떄
			# get()으로 값을 찾음
			>>> result = slang.get('bloody')
			>>> print(result)
				NONE	# 값이 없다는 뜻

		- None은 데이터가 없다는 뜻, 조건식에서 False와 같다.
			slang = {'cheerio':'goodby', 'knackered':'tired', 'yonks':'ages'}
			result = slang.get(bloody')

			if result:
				print(result)
			else:		# Otherwise
				print('Key doesn't exist')

		- 딕셔너리로 변환 : dict()
			>>> lol = [['a', 'b'], ['c', 'd'], ['e', 'f']]	# list of list
			>>> dict(lol)
				{'c': 'd', 'a': 'b', 'e': 'f'}

			>>> los = ['ab', 'cd', 'ef']	# list of string
			>>> dict(los)
				{'c': 'd', 'a': 'b', 'e': 'f'}

			>>> tos = ('ab', 'cd', 'ef')	# tuple of string
			>>> dict(tos)
				{'c': 'd', 'a': 'b', 'e': 'f'}

		- 딕셔너리에 키가 있는지 테스트
			>>> pythons = {'Chapman': 'Graham', 'Cleese': 'John', 'Johns': 'Terry', 'Palin': 'Michael'}
			>>> 'Chapman' in pythons	# 멤버쉽테스트 in은 딕셔너리에 해당 키가 있는지 확인하는 연산자이다.
				True
			>>> 'Palin' in pythons
				True
			>>> False

		- 모든 키 가져오기 : keys()
			>>> signals = 'greeen': 'go', 'yellow': 'go faster', 'red': 'stop}
			>>> signals.keys()
			dict_keys(['green', 'yellow', 'red'])

		- 모든 값 가져오기 : values()
			>>> signals.values()
			dict_values(['go', 'go faster', 'stop'])

		- 모든 키 - 값 쌍 가져오기 : items()
			>>> signals.items()
			dict_items([('green', 'go'), ('yellow', 'go faster'), ('red', 'stop')])

		- 연습문제
			다음 데이터를 리스트와 딕셔너리를 사용하여 작성하세요.
			1. 각 로우(행)를 딕셔너리로 표현한다.
				{'id': '1', 'name': 'hone kildong', 'email': 'hone@mail.com', 'hp_num': '010-2343-9870'},

			2. 4개의 딕셔너리를 포함한 리스트를 만든다.
				addresses = [
						{'id': '1', 'name': 'hone kildong', 'email': 'hone@mail.com', 'hp_num': '010-2343-9870'},
						{'id': '2', 'name': 'lee soosin', 'email': 'lee@mail.com', 'hp_num': '010-3333-5555'},
						{'id': '3', 'name': 'jang youngsil', 'email': 'jang@mail.com', 'hp_num': '010-7777-1234'},
						{'id': '4', 'name': 'king sejong', 'email': 'king@mail.com', 'hp_num': '010-8888-0987'},
				]

				addresses_new = {
						'1': {'name': 'hone kildong', 'email': 'hone@mail.com', 'hp_num': '010-2343-9870'},
						'2': {'name': 'lee soosin', 'email': 'lee@mail.com', 'hp_num': '010-3333-5555'},
						'3': {'name': 'jang youngsil', 'email': 'jang@mail.com', 'hp_num': '010-7777-1234'},
						'4': {'name': 'king sejong', 'email': 'king@mail.com', 'hp_num': '010-8888-0987'},
				}

		- 키/값 쌍으로 데이터를 처리하는 사례를 주변에서 찾아보세요.
			키는 유일한 값이 되어야하고, 그 키에 데이터를 바인딩해서 간단한 키로 데이터를 찾아오는 방식,
			예를들어 주민번호를 통해 주민의 정보를 찾을 수 있다. 키는 유일하고 중복되지 않아야한다.
			데이터베이스도 키/값 을 저장할 수 있는 데디스(Redis) 같은 DB도 많이 사용되고 있다.
			서버에서 사용자 인증을 위한 정보를 저장하는 세션도 키/값 타입으로 데이터를 사용한다.

		- 학습정리
			딕셔너리는 키/값 쌍으로 구성된 데이터 구조이다.
			딕셔너리의 아이템 끼리는 순서가 없다.
			엑셀의 표형 데이터를 딕셔너리 형태로 변경할 수 있다.

// ####################### 5교시 종료 ####################### //

// ####################### 6교시 시작 ####################### //
※ 코드구조1
	if문, 비교연산자와 논리연산자

	- 흐름 제어 (Flow Control)
		구조적 프로그래밍 : 순차구조, 선택구조, 반복구조로 이루어짐

	- bool 타입 (True: 참, False: 거짓)

	- 비교 연산자 (Comparison Operators)
		<, <=, ==, >=, >, !=

	- 논리 연산자
		결과는 True와 False
		and 와 or
		not

	- if - 조건문 (Conditional)

	- if ~ elif ~ else 다중 구문

	- True 와 False
		다음 값은 모두 Flase이다

		=====================
		요소					|| False
		=====================
		null				|| None
		int 타입 0		|| 0
		float 타입 0	|| 0.0
		빈 문자열			|| ''
		빈 리스트			|| []
		빈 튜플				|| ()
		빈 딕셔너리			|| {}

	- 간단한 단어 번역기 만들기 - 단어 첫 글자를 마지막으로 옮기고 'ay'를 추가
		단어 하나를 입력 받는다. (input() 함수 사용)
		공백을 입력하거나 글자가 아닌 것을 입력했을 때 "invalid word!"라고 출력
		입력된 단어를 수정하여 완성된 글자를 출력

	- for 문
		0부터 10까지 출력하기
		for i in [0,1,2,3,4,5,6,7,8,9,10]:
			print(i)

		for i in range(0, 11):
			print(i)

	- for 와 list (list는 tuple로도 가능, 속도가 더 빠름)
		favorite_hobby = ['reading', 'fishing', 'shopping']
		for hobby in favorite_hobby:
			print('%s is my favorite hobby' % hobby)

	- for 와 dictionary
		wish_travel_city = {'bangkok': 'Thai', 'Los Angeles': 'USA', 'Manila': 'Philiphines'}
		for city, country in wish_travel_city.items():
			print('%s in %s' % (city, country))

	- for 루프 - 리스트의 각 아이템을 순화
		====================================================
		prices = [2.50, 3.50, 4.50]

		for price in prices:
			print('Price is', price)
		====================================================
		import random

		for i in range(10):
			ticket = random.randint(1, 1000)
			print(ticket)
		====================================================
		import random
		r1 = random.random()
		print(r1)

		r2 = random.choice([1,2,3,4,5])
		print(r2)

		r3 = random.randint(1, 1000)
		print(r3)
		====================================================

	- True와 False의 두가지 상태를 가지는 컬bool 타입에 대해서 알아보세요.
		위키백과 참조: https://ko.wikipedia.org/wiki/불린_자료형

	99. 학습정리
		- 코드의 흐름제어는 분기분과 반복문으로 구분된다.
			분기문은 if문으로 반복문은 for문으로 제어할 수 있다.

		- 파이썬 데이터 타입으로 참과 거짓을 표현할 수 있는 bool타입이 있고,
			각각 True, False 키워드로 표현된다.

		- 불값을 결과로 가지는 연산자로 비교연산자와 논리연산자가 있다.


// ####################### 6교시 종료 ####################### //

// ####################### 7교시 시작 ####################### //
※ 코드구조2
	num = 0
	while num <= 10
		if num % 2 == 1:
			print(num)
		num += 1
	====================================================
	num = 1
	while 1:
		print(num)
		if num == 10:
			break		# continue?
		num += 1

	- zip() 함수를 사용하여 여러 시퀀스 병렬로 순회하기
		여러 시퀀스 중 가장 짧은 시퀀스가 완료되면 zip()은 멈춘다.
		>>> days = ['Monday', 'Tuesday', 'Wednesday']
		>>> fruits = ['1', '2', '3']
		>>> drinks = ['11', '22', '33', '44']
		>>> for day, fruit, drink in zip(days, fruits, drinks):
			print(day, ": drink", drink, "- eat", fruit, "- enjoy"...

	- zip() 함수를 사용하여 여러시퀀스 병렬로 순회하기
		여러 시퀀스 중 가장 짧은 시퀀스가 완료되면 zip()은 멈춘다.
		>>> days = ['Monday', 'Tuesday', 'Wednesday']
		>>> fruits = ['1', '2', '3']
		>>> drinks = ['11', '22', '33', '44']

		>>> list(zip(days, fruits))
			[('Monday', '1'), ('Tuesday', '2'), ('Wednesday', '3')]

		>>> dict(zip(days, fruits))
			{'Monday': '1', 'Tuesday': '2', 'Wednesday': '3'}

	- 숫자 시퀀스 생성하기 : range()
		리스트나 튜플을 사용하여 저장하지 않더라도 특정 범위의 숫자 시퀀스를 생성한다.
		>>> for x in range(0, 3):		# 0,1,2
			print(x)

		>>> list[range(0,3)]

	- zip(), range()와 같은 함수는 순회 가능한 (iterable) 객체를 반환한다.
		for .. in 형태로 값을 순회할 수 있다.
		객체를 리스트와 같은 시퀀스로 변환할 수 있다.
		>>> for x in range(2, -1, -1):			# 2부터 -1까지 -1씩 증가한다.
			print(x)

		>>> for x in range(0, 11, 2):				# 0부터 10까지 2씩 증가한다.
			print(x)

		>>> list(range(2000, 2016, 2)				# 2000부터 2016까지 2씩 증가하는 리스트를 만든다.

	- 딕셔너리에 값을 추가하려고 할 때 해당 키가 없으면 추가하는 코드
		spam = {'name': 'Pooka', 'age': 5}
		if 'color' not in spam:
			spam['color'] = 'blank'

	- setdefault()는 해당 키가 없으면 추가
		>>> spam = {'name': 'Pooka', 'age': 5}
		>>> spam.setdefault('color', 'black')
			'black'

		>>> spam
			{'color', 'black', 'name': 'Pooka', 'age': 5}

		>>> spam.setdefault('color', 'white')
			'blank'

	- Exercise : 문장 속에 나타나는 문자 개수를 카운팅해서 딕셔너리 형태로 표현
		문장 : message = 'It was a bright cold day in April, and the clocks were striking thirteen.'

		결과
			{' ': 13, ',': 1 ....... 'y': 1}

	- 과제 @@@
		# random module
		import random


		counter = {}
		for i in range(10000):
				print(i, ' : ', random.randint(1, 6))
				counter = counter.setdefault(i, 0) + 1

		# 만번 돌려서 1~6까지 몇번 나왔는지 확인 딕셔너리로 만들어라@@@@


	- 코드를 순차적 수행, 분기, 반복으로 만든 알고리즘을 처리할 수 있다는 구조적 프로그래밍에 대해서 알아보세요.
		위키백과의 구조적프로그래밍 참조:
			https://ko.wikipedia.org/wiki/구조적_프로그래밍

	99. 학습정리
		- 시퀀스 데이터구조인 스트링과 리스트는 for ~ in 문법으로 아이템들을 순회할 수 있다.
		- 딕셔너리를 순회할 때는 key/value를 각각 또는 모두 사용해 순회 할 수 있다.
		- setdefault() 함수는 딕셔너리에 값을 추가하는 함수로써 여러군데 응용된다.
// ####################### 7교시 종료 ####################### //

// ####################### 8교시 시작 ####################### //
※ 함수
	함수의 정의와 사용
		> 함수의 개념과 사용문법에 대해서 알아본다.
	함수의 파리미터
		> 파라미터의 용도와 특별한 형태에 대해서 알아본다.

	- 함수는 왜 사용하나?
		프로그램 읽고 이해하기
		코드의 재사용
		생산성과 품질 향상

	- 함수의 두 가지 작업
		정의하기 : define
		호출하기 : call

		def tax(bill):
			"""Adds 8% tax to a restaurant bill."""
			bill *= 1.08
			print("With tax: %f" % bill)
			return bill

		meal_cost = 100
		meal_with_tax = tax(meal_cost)
		meal_with_tip = tip(meal_with_tax)

	- 함수의 정의
		함수 선언은 def로 시작
		함수의 시작과 끝은 들여쓰기(indentation)로 구분
		시작과 끝을 명시하지 않음
		함수 이름 뒤에 오는 ( ) 안에 함수로 전달하는 인자(파라미터)를 적음
			def times(a, b):
				print(a * b)		# 2줄로 구분

			times(3, 5)

	- Parameter 와 return (python에서는 무조건 return이 있고 없으면 None을 넘겨준다.)

	- Practice Makes Perfect!
		1. cube라는 이름의 함수를 만들어서 number라는 파라미터를 받는다.
		2. 파라미터로 받은 숫자를 세제곱하는 코드를 만든다(자기 숫자를 세번 곱한다.)
		3. by_three라는 두 번째 함수를 만들고 number라는 파라미터를 받는다
		4. 그 숫자가 3으로 나누어지면 cube함수를 호출해서 결과를 넘겨주고, 그렇지 않으면 false를 리턴한다.

	- 함수 파라미터
		위치 파라미터
		키워드 파라미터

		def connect_URI(server, post):
			str = 'http://' + server + ':' + port
			return str

		connect_URI('test.com', '8080)								# 위치기반 파라미터
		connect_URI(port='8080', server='test.com')		# 키워드기반 파라미터

		connect_URI('test.com', port='8080')
		connect_URI(port='8080', 'test.com')


	- 기본 파라미터 값 지정
		파라미터에 기본값을 지정할 수 있다.
		함수를 호출할 때 파라미터를 제공하지 않으면 기본값을 사용한다.
			def times(a=10, b=20):
				return a * b

			x = times()
			y = times(5)

	- 함수 파라미터 : 가변 파라미터
		def var_param_test(*p):
			return p

		a = var_param_test(1,2,3,4,5)


		def_var_param_test(**p)
			for x,v in p.items():
				print(x,v)

		var_param_test(a=1, b=2, c=3, d=4)

	- 리턴 값 return
		함수를 종료하고 해당 함수를 호출한 곳으로 돌아감
		함수를 실행할 때 모든 함수 관련 리소스(변수 포함)를 스택에 저장 return 시 스택에서 제거
		파이썬은 다중값을 리턴값으로 전달 가능 (실제 튜플에 저장되어 리턴됨)
		return을 사용하지 않거나, return만 적었을 때도 함수가 종료 (None 객체를 돌려줌)

		def swap(a,b):
			return b,a

		a = swap(1,2)
		x, y = swap(1,2)

		type(a)

	- 함수의 사용이 어플리케이션의 품질향상에 어떻게 도움을 줄수 있을까요?
		함수는 재사용성을 높여준다.
		재사용성은 기존의 개발된 코드를 재사용하기에 생산성이 좋아지고,
		여러 군데에서 재사용하면서 코드가 검증이 수행되어 전체적으로 품질을 높여주는 효과가 있다.


	99. 학습정리
		- def키워드를 통해 함수를 정의할 수 있다.
		- 함수는 return 키워드를 만나면 함수의 수행이 종료된다.
		- return은 생략될 수 있으며 생략되면 None을 리턴한다.
		- 키워드 파라미터와 디폴트 파라미터는 자주 사용되며, 편리한 기능이다.

// ####################### 8교시 종료 ####################### //

// ####################### 9교시 시작 ####################### //
※ 모듈과 pip
	모듈의 개념과 사용
		>> 파이썬에서 모듈 개념을 알아보고 사용법을 알아본다.
	pip
		>> pip명령어를 사용해서 외부 모듈을 설치하는 방법을 알아본다.

	모듈은 자주사용하는 코드를 모아놓은 외부 라이브러리이다.
	외부모듈은 pip 명령어로 자동 다운로드 및 설치된다. (모듈 중앙저장소를 통해 모듈 자동 다운로드 및 설치를 지원한다.)

	모듈
		- 프로그램이 복잡해 질수록 한 파일로 프로그램을 유지하기가 힘들어짐
		- 파이썬 모듈로 분리해서 프로그램 좀 더 구조화 할 수 있음
			파이썬 파일로 별도로 분리
			import 문을 통해 모듈 사용
			>>> import random

			>>> ticket = random.randint(1, 1000)
			>>> print(ticket)


			>>> import math
			>>> answer = math.sqrt(3)
			>>> print(answer)

		- 모듈을 import하는 세 가지 방법
			import os
			from os import listdir
			import os as winos

		- 모듈 만들기
			def cal_upper(price):
				incrememt = price * 0.3
				upper_price = price + increment
				return uppper_price

			def cal_lower(price):
				decrement = price * 0.3
				lower_price = price - decrement
				return lower_price

			author = 'pystock'

			# 위코드 stock.py로 저장
			# stock.cal_upper 등으로 호출

	- 코어모듈 : 파이썬 설치 시 제공되는 내장 모듈
		>>> import sys
		>>> sys.path		# 를 통해 모듈이 설치된 경로를 확인할 수 있음

	- 써드파티 모듈 : 외부 모듈로서 별도로 설치가 필요함
		파이썬 커뮤니티에 의해 지금도 계속 개발되고 배포되고 있음

	- javascript -> node, npm
	- javascript -> maven

	- 써드파티 모듈 설치 관리자 : pypi	(파이썬 패키지 인스톨러)
		파이썬 모듈 중앙 저장소
		https://pypi.python.org/pypi
		비교해 보기 : 자바 중앙 저장소, 자바스크립트(노드), 중앙 저장소

	- requests 모듈은 파이썬에 내장되어 있지 않다.
		pip을 사용해서 설치해야 한다.
		>>> pip install requests		# 터미널에서 해야한다.
		# pip은 패키지 매니저로 파이썬 설치 시 같이 설치된다.

	- pip 설치확인 및 버전확인
		> pip --version
		> pip install requests

	- 패키지, package
		모듈 : 함수와 클래스를 정리해서 파일로 분리시키는 방법
		패키지 : 여러 모듈을 정리하는 방법을 제공
		파이썬 패키지는 모듈을 모아놓은 디렉터리
			# __init__.py 파일이 디렉터리에 위치하면 파이썬은 패키지로 인신
			# import는 from ... import 문법을 사용		(from os import listdir)

	- 모듈과 패키지를 사용하여 프로그램을 구조화 예제
		End User	<->	Web Interface	<->		Backend

	- 데모 : 패키지
		이전에 작성한 calculator.py 모듈을 services패키지를 만ㄷ르어 해당 패키지로 이동
		main.py 모듈을 실행 가능하게 수정

	- 둘중에 하나 선택해서 쓰자
		from services import calculator as cal
		import services.calculator as cal

	- 파이썬 내장 함수
		자주 사용되는 함수들을 내장 함수 (Built-in Functions)라는 이름으로 기본적으로 제공

	- activestate 사이트에서 작은 코드 예제를 많이 찾을 수 있다.
		http://code.activestate.com/recipes/langs/python

	- 다양한 내장 함수의 사용 예

	- 모듈러 프로그래밍 이란?
		네이버 국어사전 : 프로그램을 부품처럼 설계하는 방법.
		프로그램을 모듈화하여 독립성을 갖도록 함으로써 다른 모듈에
		영향을 받는 일이 없이 일부 모듈의 개량이나 재번역이 가능하다.

	99. 학습정리
		- 프로그램이 커짐에 따라 파일로 분리하여 개발할 수 있다.
		- 모듈은 파이썬 설치시 같이 설치되는 코어 모듈과 pip 명령어로
			별도로 설치해서 사용할 수 있는 써드파트 모듈로 분류된다.
		- 관련있는 파일들을 모아두는 디렉토리로 패키지를 사용할 수 있다.
// ####################### 9교시 종료 ####################### //


// ####################### 10교시 시작 ####################### //
※ 문자 다루기 2
	- 문자 다루기 관련 함수
		문자를 다루는 여러가지 함수와 방법에 대해서 알아본다.

	- 문자열 길이 len()
	- 문자열 나누기 : split()
	- 문자열 결합 : join()
		>>> crypto_list = ['a', 'b', 'c']
		>>> crypto_string = ', '.join(crypto_list)
		>>> crypto_string
			a, b, c

	- in, not in 연산자
		>>> 'Hello' in 'Hello World'
			True
		>>> 'Hello' not in 'Hello World'
			False

	- upper(), lower(), isupper(), islower() 함수
		upper() : 대문자변환
		lower() : 소문자변환
		isupper() : 전체 대문자냐?
		islower() : 전체 소문자냐?

	- isX 문자열 함수 (입력 유효성 체크로 사용)
		isalpha() : 문자로만 구성 시 True
		isalnum() : 문자와 숫자로만 구성시 True
		isdecimal() : 숫자로만 구성 시 True
		isspace() : 공백으로만 구성 시 True
		istitle() : 대문자로 시작 문장 형식이면 True

	- 패스워드 검증기
		1. input() 함수로 사용자로부터 패스워트를 입력 받는다.
		2. 패스워드 규칙
			8자 이상이고, 영어와 숫자가 혼합된 형태이어야 함
		3. 입력된 패스워드가 규칙에 맞으면 True, 틀리면 False를 리턴한다.
		4. 패스워드를 검증하는 부분을 별도의 함수로 작성하고, 최종적으로 적절한 메시지를 출력한다.
			def validate_password(password=''):
					if len(password) < 8:
							return False
					elif password.isalpha():
							return False
					elif password.isnumeric():
							return False
					else:
							return True



			def main():
					user_password = input('input your password: ')

					if validate_password(user_password):
							print('valid password')
					else:
							print('not valid password')


			main()

	- startswith(), endswith() 함수
		>>> 'Hello world!'.startswith('Hello')
			True
		>>> 'Hello world!'.endswith('Hello')
			False

	- 포매팅
		데이터 값을 문자열에 끼워 넣는 (interpolate)방법을 제공

	- 파이썬2 버전의 포매팅
		옛 스타일 : %
			>>> 'my home is %s gu %s dong %d bunji' % (gu, dong, bunji)
			>>> 'my home is %s gu %s dong %d bunji' % ('gu', 'dong', 123)

	- 파이썬 3 버전의 포매팅
		새로운 스타일 : { } 와 format
		파이썬 2방식도 지원되나 파이썬 3에서는 새로운 방식 포매팅을 권장
			>>> '{} {} {}'.format(gu, dong, bunji)
			>>> '{2} {0} {1}'.format(gu, dong, bunji)																		# 파라미터 순서 정할 수 있다.
			>>> '{gu} {dong} {bunji}'.format(gu='seocho', dong='yangjae', bunji=123)		# 제일 직관적이다

			>>> d = {'gu': 'seocho', 'dong': 'yangjae', 'bunji': 123}										# dictionary 형태로 바인딩 가능
			>>> '{0[gu]} {0[dong]} {0[bunji]}'.format(d)

	- pyperclip 모듈
		copy(), paste() 함수로 텍스트를 클립보드에 복사하고 붙이기를 지원
		>>> import pyperclip			# pip install pyperclip 해야한다.
		>>> pyperclip.copy('Hello world!')
		>>> pyperclip.paste()
			'Hello world!'

	- Terminal	(기존에 깔린거 확인할떄)
		>>> pip list

	- 연습문제 : Password Locker
		사이트와 패스워드를 딕셔너리에 저장해 두고, 사이트를 커맨드라인으로 전달하면 패스워드를 클립보드에 자동으로 복사해준다.
		1. 데이터 구조 정의
			PASSWORDS = {
				'gmail': 'gmail123',
				'naver': 'naver123',
				'facebook': 'facebook123',
			}

		2. input() 함수로 사이트 명을 입력 받는다.
		3. 해당 패스워드를 클립보드에 복사한다.
		4. 붙혀넣기로 패스워드를 사용한다.

	[빅데이터 분석] 텍스트마이닝이란?
		https://m.blog.naver.com/PostView.nhn?blogId=koys007&logNo=220932161947&proxyReferer=https%3A%2F%2Fwww.google.co.kr%2F

	문자열로 구성된 문서에서 특정 데이터나 정보를 추출하는 것을 텍스트마이닝이라고 한다.
	텍스트마이닝에 대해서 조사해 보세요.
		>>> 비정형 텍스트 데이터에서 가치와 의미가 있는 정보를 찾아내는 기법.
				예들 들면, 인터넷 등에 올라온 글에서 특정 주제와 관련된 부분을 뽑아 의미를 분석하고
				필요한 정보를 추출하는 기법을 말한다.
				데이터 마이닝이 구조화되고 사실적인 방대한 데이터베이스에서 관심있는 패턴을 찾아내는 기술 분야라면,
				텍스트 마이닝은 구조화되지 않은 텍스트에서 의미를 찾아내는 기술분이야다.


	99. 학습정리
		- split()과 join() 함수를 통해 각각 문자열을 리스트로 리스트를 문자열로 변환할 수 있다.
		- 문자열과 리스트, 튜플 같이 아이템이 순서를 가지는 형태의 구조를 시퀀셜 타입이라고 한다.
		- isX함수들을 통해 스트링의 구성요소를 알수 있다.
// ####################### 10교시 종료 ####################### //

// ####################### 11교시 시작 ####################### //
※ 정규표현식1
	- 정규표현식 문법
		정규표현식의 개념과 문법을 알아본다.

	- 정규식 : Regular Expression
	- 텍스트를 검색할 때 Ctrl+F로 찾는 것을 조금 더 발전시킨 형태
		글자 자체를 가지고 찾는게 아니라 패턴이라는 것을 사용함
		오피스 프로그램은 찾기(바꾸기) 기능에서 정규식을 지원함

	- 정규식 사용 사례
		입력 유효성 체크(Form Validation)
			> 이메일 주소가 맞는지 아닌지
		텍스트에서 특정 부분을 추출
			> 우편번호 추출
		특정 텍스트 바꾸기
			> 계란 -> 달걀
		큰 텍스트를 작게 쪼개기
			> 콤마나 점으로 구분해서 문장 쪼개기

	- 정규식 문법 배우기
		/ ... / 속에 패턴을 표기

	- 패턴으로 찾기 데모 : 다음 두 개의 패턴으로 정규식을 배우자!
		010-3456-0123
			> 전화번호 패턴 나타내기
		kang.deokjoon@naver.com
			> 이메일 주소 패턴 나타내기

	- 정규식 연습하기 (https://regex101.com)
		> 아래는 실제 정규식
			010|011										# | 은 또는
			\d	# 숫자 1개
			\d\d\d-\d\d\d\d-\d\d\d\d
			[1]\d\d-									# 1로시작하면서 숫자 2개인것은?
			[0][0-9][0|1|6|9]-				# 0으로시작하고 0~9까지 & 0,1,6,9이면서 - 로 시작하는것
			[0]\d\d(-|\.)\d\d\d\d			# (-|\.)     >>> - or .
			[0]\d\d(-|\.)....-....		# .					>>> \n을 제외한 모든 문자

	- 참고사이트 @@@
		https://regex101.com
		https://regexr.com

	1. 전화번호 패턴
		>> \d\d\d-\d\d\d\d-\d\d\d\d

		- \d : 0부터 9까지 숫자
		- \w : 숫자와 문자(대소문자 포함), _(언더스코어)
		- \s : 공백문자
		- . : \n을 제외한 모든 문자

	1. 전화번호
		- [] 속에 글자들은 순서에 관계없이 한 글자를 표현
		- [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]
		- 다른 표현 : [0][1][01689]-[0-9][0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]

	1. 전화번호
		- [0-9]{3}-[0-9]{4}-[0-9]{4}
		- ? : 0번 또는 1번 발생 (zero or one)
		- * : 0번 또는 여러번 발생 (zero or many)
		- + : 1번 이상 발생 (one or many)
		- {n} : n번 발생

	2. 이메일 주소 패턴
		- [a-zA-Z0-9._%+-]		# 사용자 이름
		- @										# @ 심벌
		- [a-zA-Z0-9.-]+			# 도메인명
		- \.(com|net|co.kr)		# dot something
		- |(파이프)							# 다중매칭

	9. 연습문제 : 웹 주소 패턴 표현하기
		- \b(https?:\/\/)?([\w.]+){1,2}(\.[\w]{2,4}){1,2}\b
				>>>>>>>>>> https? 는 http일수도 있고, http일수도 있다
				>>>>>>>>>> (https?:\/\/)? 는 아에 http로 시작하는게 있을수도 없을수도 있다.

			/	문자를 표현할떄	: 이스케이프를 사용 (\/)
			\b						: 바운더리를 표현	(양쪽에 아무문자가 없다)
			()						: 괄호를 사용하여 그룹을 적절히 활용
			.							: 문자(dot)는 와일드카드, \n 문자 제외하고 모든 문자에 대응
			실제로 .을 표시하고 싶으면 \.으로 사용
			^							: 시작을 표시
			$							: 끝을 표시


	1. 정규식을 사용한 텍스트 패턴 검색
		- match() : 원하는 문자열 패턴으로 소스 문자열과 일치하는지 비교
			result = re.match('hello', 'hello world')		# 'hello'는 패턴이고 'hello world'는 확인 할 소스 문자열이다

		- result : 결과가 None이면 매칭이 실패했다는 의미

	2. 패턴을 미리 컴파일 할 수 있다.
		phonenum_regex = re.compile(r'\d\d\d-\d\d\d-\d\d\d\d')

	3. 패턴과 소스를 비교하는 다른 방법
		search()	: 첫 번째 일치하는 객체를 반환
		findall()	: 모두 일치하는 문자열을 리스트로 반환
		split()		: 패턴에 맞게 소스를 쪼갠 후 문자열 조각의 리스트를 반환
		sub()			: 바꾸기 기능, 패턴과 일치하는 소스의 부분을 대체인자로 변경

	4. 정규식의 역사에 대해서 알아보세요.
		정규 표현식은 스티븐 클레이니가 정규 집합(regular set)이라는 자신의 수학적 개념을 이용하여 정규 언어를 기술한 1956년이 기원이다.
		[2] 형식 언어와 관련된 오토마타 이론의 하위 분야이자 이론 전산학에서 발생하였다.
		패턴 일치의 초기 구현체들에는 SNOBOL 언어가 있으며, 실제로 정규식을 사용한 것은 아니지만 대신 독자적인 패턴 일치 구성체를 이용하였다.
		(위키백과 정규식중)

	99. 학습정리
		- 정규식을 사용하면 패턴을 이용하여 문서내의 특정 문자를 추출 할 수 있다.
		- 정규식을 췝 상에서 테스트 해 볼수 있는 사이트를 이용하여 정규식을 학습할 수 있다.

// ####################### 11교시 종료 ####################### //

// ####################### 12교시 시작 ####################### //
※ 정규표현식2
	search() : 첫 번째 일치하는 객체를 반환한다.
		>>> phonenum_regex = re.compile(r'\d\d\d-\d\d\d-\d\d\d\d')
		>>> mo = phonenum_regex.search('My number is 415-555-4242.')
		>>> print('Phone number found: ' + mo.group())
			Phone number found: 415-555-4242

		1. re 모듈 임포트 : import re
		2. re.compile() 함수로 Regex 객체를 생성 (raw string 사용)
		3. search()함수의 파라미터로 검색할 문자를 전달
			- Match 객체를 반환
		4. group() 함수로 실제 매칭된(검색된) 문자열 리턴

	그룹핑 : 괄호를 사용하여 정규식(regex)에 그룹을 생성할 수 있다.
		(\d\d\d)-(\d\d\d-\d\d\d\d) : group() 함수 사용
			>>> phonenum_regex = re.compile(r'(\d\d\d)-(\d\d\d-\d\d\d\d)')
			>>> mo = phonenum_regex.search('My number is 415-555-4242.')

			>>> mo.group(1)
				'415'
			>>> mo.group(2)
				'555-4242'
			>>> mo.group(0)
				'415-555-4242'

			>>> mo.groups()
				('415', '555-4242')
			>>> area_code, main_number = mo.groups()
			>>> print(area_code)
				415
			>>> print(main_number)
				555-4242


	findall() : 모두 일치하는 문자열을 리스트로 변환
		search() 는 매칭되는 첫 번째 패턴을 반환. findall() 모든 패턴 반환

		>>> phonenum_regex = re.compile(r'\d\d\d-\d\d\d-\d\d\d\d')
		>>> mo = phonenum_regex.search('Cell: 415-555-9999 Work: 212-555-0000')
		>>> mo.group()
			'415-555-9999'

		>>> phonenum_regex = re.compile(r'\d\d\d-\d\d\d-\d\d\d\d')	# has no groups
		>>> mo = phonenum_regex.findall('Cell: 415-555-9999 Work: 212-555-0000')
			['415-555-9999', '212-555-0000']

		>>> phonenum_regex = re.compile(r'(\d\d\d)-(\d\d\d)-(\d\d\d\d)')	# has groups
		>>> mo = phonenum_regex.findall('Cell: 415-555-9999 Work: 212-555-0000')
			[('415', '555', '9999'), ('212', '555', '0000')]


	플래그 : I와 VERBOSE
		- 대소문자 구분 무시 : re.I
			>>> robocop = re.compile(r'robocop', re.I)
			>>> robocop.search('Robocop is part man, part machine, all cop.').group()
				'Robocop'

			>>> robocop.search('ROBOCOP protects the innocent.').group()
				'ROBOCOP'

		- 복잡한 정규식 표현 : re.VERBOSE
			# Create email regex.
				email_regex = re.compile(r'''(								# '''		=> multi line 문자
					[a-zA-Z0-9._%+-]+					# username
					@													# @ symbol
					[a-zA-Z0-9.-]+						# domain name
					(\.[a-zA-Z]{2,4}){1,2}		# dot-something
					)''', re.VERBOSE)

	- search() : 첫 번쨰 일치하는 객체를 반환한다.
		1. re 모듈 임포트 : import re
		2. re.compile() 함수로 Regex 객체를 생성 (raw string 사용)
		3. search() 함수를 파라미터로 검색할 문자를 전달
			- Match 객체를 반환
		4. group() 함수로 실제 매칭된 (검색된) 문자열 리턴

	연습문제 : 이메일 추출기
		1. 웹페이지나 문서 내에서 수작업 대신에 regex를 사용하여 추출해보자
			- 대상 문서 전체를 선택해서 Ctrl-A 클립보드로 복사한다 Ctrl-C
			- 그리고 프로그램을 실행한다 (끝)
				1. 클립보드에서 텍스트를 가져온다.
				2. 텍스트에서 이메일 주소를 가져온다.
				3. 클릭보드에 다시 복사한다.

			- 코딩절차
				1. pyperclip 모듈을 사용해 복사와 붙여넣기 수행
				2. regex를 만든다. 이메일 주소를 매칭한다.
				3. 모든 매치를 찾는다.
				4. 매칭된 스트링을 하나의 문자열로 만든다.
				5. 매칭된 문자열이 없으면 간단한 메시지를 출력한다.


	def copy_result_to_clipboarrd(matches):
			# Copy results to the clipboard.
			pass		# pass는 함수 그냥 pass 한다는 의미 (작업중일때)



	웹에서 정규식을 테스트 해볼 수 있는 사이트를 알아보고 가장 자신에 적합한 사이트를 찾아보세요.
		https://regex101.com, http://regexr.com/ 등의 사이트가 있다.

	복잡한 정규식을 표현하기 위한 플래그는 무엇인가?
		VERBOSE

	99. 학습정리
		- re모듈의 compile() 함수를 사용하여 패턴을 미리 만들어 둘 수 있다.
		- search()는 첫번째 매칭되는 문자열을, findall()은 모든 매칭 문자열을 가져온다.
		- VERBOSE 플래그를 사용하여 복잡한 정규식을 보기좋게 표현할 수 있다.
// ####################### 12교시 종료 ####################### //

// ####################### 13교시 시작 ####################### //
※ 파일 다루기
	텍스트 파일을 읽고 쓰는 방법에 대해서 알아본다.


	1. 프로그램이 실행 중일 때는 데이터를 랩(RAM)에 저장한다.
		- RAM은 휘발성
	2. 데이터의 영구저장(Persistence)을 위해 파일을 사용한다.
		- 디스크와 같은 비휘발성(non-volatile) 장치를 사용
	3. 파일의 생성과 사용에 관련된 내용을 다룸
		- 디렉터리의 이동과 생성, 삭제
		- 파일의 생성, 쓰기, 읽기

	1. 파일과 파일경로
		리눅스와 맥에서는 ( / )를 사용, 윈도우에서는 ( \ ) 사용
		>>> import os
		>>> os.path.join('usr', 'bin', 'spam')
			'usr\\bin\\spam'

		>>> myFiles = ['accounts.txt', 'details.csv', 'invite.docx']
		>>> for filename in myFiles:
			...
			print(os.path.join('C:\\Users\\python', filename))

		C:\Users\python\accoutns.txt
		C:\Users\python\details.scv
		C:\Users\python\invite.docx

	2. 윈도우의 dir과 리눅스의 ls 명령과 유사한
		glob 모듈
		glob.glob('*')		: 현재 디렉터리의 모든 파일을 리스트로 반환
		glob.glob('*.py')	: py 확장자인 것만 리스트로 반환

	1. 현재 작업 디렉터리 : Current Working Directory
		os.getcwd() : 현재 작업디렉터리를 보여줌
		os.chdir() : 디렉터리 변경
			>>> import os
			>>> os.getcwd()
				'C:\\Python34'
			>>> os.chdir('C:\\Windows\\System32')
			>>> os.getcwd()
				'C:\\Windows\\System32'

	1. Dir name과 base name
		>>> path = 'C:\\Windows\\System32\\calc.exe'
		>>> os.path.basename(path)
			'calc.exe'

		>>> os.path.dirname(path)
			'C:\\Windows\\System32'

	1. 파일 - 쓰기와 읽기
		- w : 쓰기
		- r : 읽기
		- a : 추가

		sales_log = open('spam_orders.txt', 'w')		# open
		sales_log.write('The Spam Van')							# write
		sales_log.write('Sales Log')
		sales_log.close()														# close

		dollar_spam = open('spam_orders.txt', 'r')	# open
		print(dollar_spam.read())										# read
		dollar_spam.close()													# close


	1. readline 함수와 readlines 함수 사용
		# 한 라인
		f = open("new_file.txt", 'r')

		line = f.readline()
		print(line)
		f.close()


		# 여러 라인 (텍스트 파일이 작을때 주로 씀 - lines라서 모두 메모리에 올리면 부하가...상당함)
		f = open("새파일.txt", 'r')
		lines = f.readlines()

		for line in lines:
			print(line)

		f.close()


		# 여러라인 (주로 사용을 권장함)
			f = open("new_file.txt", 'r')

			while True:
				line = f.readline()		# 1개의 line씩 메모리에 올림으로 대량일때 좋음
				if not line: break
				print(line)

			f.close()								# close를 꼭 해줘서 release해줘야함!!!!!!!!!!!!!.

		# 아래방법이 제일 좋음 @@@
		# close을 안할수도 있어서 대체 문법이 나옴 @@@
		with open("foo.txt", 'w') as f:			# 가능하면 이방법을 사용하는게 제일 좋음 (with 구문이 끝나면 f를 자동으로 close 해줌)
			f.write("Life is too short, you need python")

	99. 연습문제
		텍스트 파일을 읽고, 수정하고, 저장하기
			1. 자막 파일을 읽는다.
				파일을 라인단위로 읽어서 리스트에 저장
			2. 자막 관련 다른 정보는 모두 제거하고 자막 문자열만 남긴다.
				자막 내용만 남기고 나머지는 제거하여 새로운 리스트를 생성
			3. 리스트의 내용을 다시 파일로 생성하여 저장한다.


	질문. 윈도우와 리눅스의 파일관련 다른점
		참고 : https://www.howtogeek.com/137096/6-ways-the-linux-file-system-is-different-from-the-windows-file-system/
		1. 디렉토리 구조 (윈도우 \사용, 리눅스 /사용)
		2. 대소문자 구분 (윈도우는 대소문자 구분하지 않지만 리눅스는 구분함)
		3. 드라이브 이름 사용 여부
		4. 리눅스는 모든것을 파일로 취급
		5. 파일을 사용중일 때 락은 거는것 (윈도우:엄격, 리눅스:덜 엄격)

	디렉토리 삭제는 os.rmdir(path) 나 shtuil.rmtree(path)를 사용한다.

	99. 학습정리
		- os모듈은 운영체제의 파일시스템에 접근할 수 있는 여러 함수를 제공한다.
		- 파일을 읽고 쓸 떄 모두 open() 함수를 사용한다.
		- 파일 컨텍스트 문법을 사용하면 파일 사용 후 close()함수로 닫아줄 필요가 없다.

// ####################### 13교시 종료 ####################### //

// ####################### 14교시 시작 ####################### //
※ 파일과 디렉터리 다루기
	1. 파일과 디렉토리 다루기
		- 파일과 디렉토리의 복사, 이동, 삭제 등의 작업을 수행한다.
		- ZIP포맷으로 압축관련 작업을 수행한다.

	1. pickle 모듈 사용
		리스트나 클래스를 파일에 저장할 떄 사용
		import pickle

		colors = ['red', 'green', 'black']

		f = open('colors.pickle', 'wb']		# wb에서 b는 binary (쓰기인데 binary로 써라!)
		pickle.dump(colors, f)
		f.close()


		import pickle

		del colors

		f = open('colors.pickle', 'rb')
		colors = pickle.load(f)
		print(colors)
		f.close()

	1. 파일과 디렉터리 관리에 대해서 다룸
		- 하드디스크에 저장된 파일과 디렉터리의 관리 작업을 자동화
		- 특정 확장자를 가진 파일 또는 특정 이름 패턴을 가진 파일을 지우거나 다른 디렉터리로 옮기기
		- 파일이나 디렉터리를 압축하여 별도 저장 (일종의 백업 시스템)

	2. shutil (Shell Utils) 모듈
		- 파일이나 디렉터리를 복사, 이동, 리네임, 삭제를 수행하는 모듈

		- shutil.copy(source, destination)
			>>> import shutil, os
			>>> os.chdir('C:\\')
			>>> shutil.copy('C:\\spam.txt', 'C:\\delicious')
				C:\\delicious\\spam.txt'
			>>> shutil.copy('C:\\eggs.txt', 'C:\\delicious\\eggs2.txt')
				C:\\delicious\\eggs2.txt'

		- shutil.move(source, destination)
			타깃 디렉터리에 이동하고자 하는 파일이 있으면 무브가 안됨
			>>> import shutil
			>>> shutil.move('C:\\bacon.txt', 'C:\\eggs')
				'C:\\eggs\\bacon.txt'
			>>> shutil.move('C:\\bacon.txt', 'C:\\eggs\\new_bacon.txt')
				'C:\\eggs\\new_bacon.txt'
			>>> shutil.move('C:\\bacon.txt', 'C:\\eggs')
				'C:\\eggs\\eggs'

	3. 파일과 디렉터리 영구삭제
		- os.unlick(path) / os.remove(path)
		- os.rmdir(path) : 해당 경로가 비어있어야 함
		- shutil.rmtree(path) : 경로가 비어있지 않아도 모든 파일이 삭제됨

	4. 안전 삭제 : send2trash 모듈
		설치 : pip install send2trash
			- 삭제된 파일이나 디렉터리를 운영체제의 휴지통으로 보낸다.
			- 완전 삭제가 아니라 나중에 복원이 가능하다.
			>>> import send2trash
			>>> baconFile = open('bacon.txt', 'a')	# creates the file
			>>> baconFile.write('Bacon is not a vegetable.')
				25
			>>> baconFile.close()
			>>> send2tash.send2trash('bacon.txt')

	※ 디렉터리 트리 운행
		1. 디렉터리 순회 : os.walk(path)
			!!! os.walk(path)를 for 문을 통해 하루 디렉터리 전체 순회 가능
				- foloder_name : 현재 폴더명
				- subfolders : 하위 폴더 목록 리스트 (폴더명으로 구성)
				- filenames : 현재 폴더의 파일 목록

			import os

			for folder_name, subfolders, filenames in os.walk('C\\deliciouse'):
				print('The current folder is ' + folder_name)

				for subfolder in subfolders:
					print('SUBFOLDER OF ' + folder_name + ' : ' + subfolder)
				for filename in filenames:
					print('FILE INSIDE ' + folder_name + ' : ' + filename)

				print('')

		2. ZIP 파일 읽기
			- 먼저, ZipFile 객체를 만든다 : zipfile.ZipFile(file)
				>>> import zipfile, os
				>>> os.chdir('C:\\')	# move to the folder with example.zip
				>>> exampleZip = zipfile.ZipFile('example.zip')
				>>> exampleZip.namelist()
					['spam.ext', 'cats/', 'cats/catnames.txt', 'cats/zophie.jpg']
				>>> spamInfo = exampleZip.getinfo('spam.txt')
				>>> spamInfo.file_size
					13908
				>>> spamInfo.compress_size
					3828
				>>> exampleZip.close()

		3. ZIP 파일 압축 풀기
			- extractall() : 현재 디렉터리에 파일과 디렉터리 압축 해제
			- extract(file_name) : 해당 파일만 압축 해제
				>>> os.chdir('C:\\')		# move to ther folder with example.zip
				>>> exampleZip = zipfile.ZipFile('example.zip')
				>>> exampleZip.extractall()
				>>> exampleZip.close()

		4. ZIP 압축하기
			- ZipFile 객체를 만들 떄 'w' 옵션을 부여 : zipfile.ZipFile('new.zip', 'w')
				'w'모드는 파일이 새로 만들어지며, 기존 파일이 있으면 내용이 모두 지원진다.
				컨텐츠를 추가하려면 'a'모드를 사용한다.

				>>> import zipfile
				>>> newZip = zipfile.ZipFile('new.zip', 'w')
				>>> newZip.write('spam.txt', compress_type=zipfile.ZIP_DEFLATED)		# zipfile.ZIP_DEFLATED 이란 zipfile 압축 알고리즘
				>>> newZip.close()

		5. ZIP 파일에 파일 추가
			ZIP파일을 새로 만들고 파일을 추가하는 방식 :
				backup_zip.write(file_name)

	99. 연습문제 : 특정 디렉터리를 ZIP 파일로 압축하여 백업하기
		1. ZIP 파일명 정하기
		2. 디렉터리 트리를 모두 탐색하여 ZIP 파일로 생성
		3. 백업 디렉터리에 ZIP파일 저장
			기타 : .jpg파일만 제외하고 압축하여 백업

	- 계층구조 알고리즘
		재귀적인 방법으로 모든 서브 디렉토리와 파일들을 탐색하는 방법이 주로 사용됩니다.
		파이썬에서는 os.walk() 함수가 있습니다.

	99. 학습정리
		- pickle 모듈을 사용하면 파이썬 데이터 구조를 바이너리 파일로 저장하고 다시 메모리로 복원할 수 있다.
		- shutil 모듈은 파일과 디렉토리를 조작하는 여러 함수를 제공한다.
		- os.walk() 함수로 하위 디렉토리와 파일들을 재귀적으로 순회할 수 있다.
		- zipfile 모듈을 사용하여 압축 관련 작업을 수행할 수 있다.

// ####################### 14교시 종료 ####################### //

// ####################### 15교시 시작 ####################### //
※ 예외처리와 로깅
	프로그램 강제로 종료되는 것을 방지하는 코드를 작성한다.
	print() 함수를 대체하여 로깅하는 방법에대해 알아본다.

	1. 프로그램의 비정상적인 종료를 막는 방법
		1.1. 에러가 발생할 가능성이 있는 코드를 사전에 처리해주는 방법
			예) 파일을 다룰때 파일이 없거나 쓰기금지로 설정된 경우
				- 데이터베이스 연결 시 DB쪽 이슈
				- 네트워크 관련 코드에서 네트워크 이슈

		1.2. try, except를 이용한 에러로부터의 복수
			try:
				file = open('sales.txt', 'r')
				print(file.read())
			except:
				print('FIle doesn't exist')

		1.3. 파이썬은 60여 개 이상의 예외가 있음
			price = input('Enter the price : ')

			try:
				price = float(price)
				print('Price =', price)
			except ValueError:
				print('Not a number!')


			try:
				price = float(price)
				print('Price =', price)
			except ValueError as err:
				print(err)

		1.4. 사용자 정의 예외 만들기
			- 새로운 예외 타입을 만들기 위해서는 class객체 타입을 정의해야 함
				class BizException(Exception)
					pass

		1.5. 예외발생 : raise
			- 특정한 상황에서 예외를 발생시킬 수 있음
				raise BizException

				try:
					raise BizException('error occurred')
				except BizException as e:
					print(e)

	2. logging 모듈
		2.1. 로그 메시지를 디스플레이 하고자 할 떄 사용
			- 코드 제일 위쪽에 로깅 설정 코드를 추가
				import logging

				logging.basicConfig(level=logging.DEBUG, format=' %(asctime)s -%(levelname)s - %(message)s')

		2.2. 로그 메시지를 파일로 저장
			- 로깅 설정 코드 부분을 수정
				import logging

				logging.basicConfig(filename='myProgramLog.txt',
														level=logging.DEBUG,
														format=' %(asctime)s -%(levelname)s - %(message)s')

		2.3. 과제
			- batch는 계속 쌓인다, 하루마다 로그파일 다르게 설정하는 방법

	99. 로그의 중요성?
		로그란 운영체제 혹은 애플리케이션의 동작상태를 추후에 개발자나 운영자가 확인하기 위해서 기록하는 정보를 의미한다.
		우리가 주변에서 볼 수 있는 것 중 프롤그램의 로그와 가장 비슷한 개념은 자동차나 비행기에 설치된 블랙박스 기록일 것이다.
		로그를 활용해서 프로그램의 동작 상황을 알 수 있어 프로그램을 개발 및 디버깅 할때 도움이 된다.
		로깅은 프로그램 실행과는 별개의 오버헤드라고 할 수 있기에 최대한 프로그램의 성능에 영향을 덜 주는 것이 중요하다.
		파이썬에서는 print() 함수를 사용하는 것 보다 로그를 위한 별도의 모듈을 사용하는 것이 좋다.

	99. 학습정리
		- 프로그램의 여러 예외상황에도 프로그램을 정상적으로 동작시키는 코드를 위해 예외처리가 필요하다.
		- try: ~ except: 구를 사용한다.
		- 로깅은 별도의 쓰레드로 수행되어 전체 성능을 향상시킨다.

// ####################### 15교시 종료 ####################### //

// ####################### 16교시 시작 ####################### //
※ 객체와 클래스
	※ 파이썬에서의 객체지향 프로그래밍
		- 클래스 작성과 객체 생성에 대해서 알아본다.
		- 상속에 대해서 알아본다.

	1. 객체지향 프로그래밍 - Object Oriented Programming
		- Programming paradigm
		- 데이터를 포함한 데이터구조 (field, attribute)와
			함수(function, procedure, 메서드라고 부름)로 구성
		- 객체 내부에 포함된 데이터를 메서드를 통해 수정 가능
			(this 또는 self 키워드 사용)
		- 프로그램은 모두 객체로 분해되어 설계되고, 객체 간 서로 상호작용을 통해 수행됨
	2. 클래스 선언
		class Person:
			name = 'kim soongon'
			gender = 'male'
			address = 'seoul'

			def set_name(self, name):
				self.name = name

			def print(self):
				print("my name is {0}".format(self.name))

	3. 클래스 문법
		- class 키워드로 시작됨
		- class 키워드 다음에 클래스 이름이 위치
		- class 이름 뒤에 괄호 속에 상속된 클래스 이름이 위치
			class NewClass(object):
				# Class magic here
		- 파이썬의 object 클래스의 기능과 속성을 모두 상속 받는다.
		- 사용자가 작성한 클래스(user-defined class)는 대문자로 시작하게 이름을 짓는다(Naming Convention)		# class 첫글자 대문자 (파스칼)

	4. 클래스 만들기 실습
		4.1. Animal이라는 이름의 클래스를 만든다. (object 클래스 상속받는다)
		4.2. 클래스 내부에 pass라는 키워드를 적는다. (pass는 아무일도 하지 않는다)
		4.3. pass를 지우고 그 자리에 생성자를 만든다.
		4.4. def __init__(self): 라는 이름의 생성자를 만든다. self를 파라미터로 적는다.
		4.5. 생성자 메소드 내부에 pass를 적는다.
		4.6. 클래스에서 객체를 생성한다.
			cat = Animal()

	5. __init__() 메소드와 self
		5.1. 생성자 : 객체가 생성될 떄 자동으로 실행되며, 생성시 필요한 코드를 포함
			- __init__(self)

		5.2. self : 생성자 파라미터로 사용되며, 생성된 객체의 멤버를 접근할 때 사용
			# Class definition
			class Animal(object):
				def __init__(self, name, age, is_hungry):
					self.name = name
					self.age = age
					self.is_hungry = is_hungry

			zebra = Animal("Jeffry", 2, True)
			giraffe = Animal("Bruce", 1, False)
			panda = Animal("Chad", 7, True)

			print(zebra.name, zebra.age, zebra.is_hungry)
			print(giraffe.name, giraffe.age, giraffe.is_hungry)
			print(panda.name, panda.age, panda.is_hungry)

		5.3. 메소드, methods : 클래스 내부에 존재하는 함수
			class Animal(object):
				is_alive = True
				health = "good"

				def __init__(self, name, age):

	6. 상속 Inheritance
		6.1. 객체 재사용의 한 방법 - 다른 방법으로는 포함(Composition)이 있음
		6.2. 부모 클래스의 모든 속성(데이터, 메서드)를 자식 클래스로 물려줄 수 있음
			class Person(object):
			...

			class Student(Person):		# Person 상속받아서 Student Class 생성 (생성자를 제외한 변수, 메소드 등을 상속받는다)
			...

		6.3. 상속 연습문제
			- Triangle 클래스를 Shape를 상속해 만든다.
			- __init__ 생성자를 만들고, self, side1, side2, side3 파라미터 만든다.
			- self.side1 = side1, self.side2 = side2, self.side3 = side3 코드를 생성자 내부에 만든다.
			- 클래스를 테스트 한다.

	7. Override
		7.1. 상속된 부모클래스의 메소드나 속성을 재정의 하는 행위
		7.2. 아래 코드에서 CEO 클래스는 Employee를 상속 받았으며, greet 메소드를 overriding했다.

	99. 연습문제
		클래스는 복잡한 데이터와 메소드를 저장하기에 매유 유용한 데이터 구조이다.
		1. "Car"클래스를 만든다. 내부는 pass 키워드로 처리한다.
		2. member variable을 만든다.
			- pass 키워드를 제거하고, condition변수를 만들고 "New" 값을 할당한다.
			- my_car 라는 Car 객체를 생성하고 멤버변수 condition 값을 print 한다.
		3. 객체가 생성될 떄 마다 호출되는 생성자 (__init__)을 만든다.
			- 4개의 파라미터를 받는다. - self, model, color, mpg
			- 생성자를 통해 객체를 생성한다.
		4. 멤버변수에 접근하다.
			- my_car 객체의 멤버변수 3개를 각각 print 한다.
		5. 메소드를 만들어 본다.
			- Car 클래스 안에 display_car() 메소드를 만든다.
			- 스트링을 리턴한다. - "This is a [color][model] with [mpg] MPG."
			- my_car 객체에서 display_car() 메소드를 호출하여 print한다.
		6. 클래스 멤버변수에 접근한다.
			- drive_car 메소드를 추가해서 condition 값을 'used'로 바꾸고 값을 print한다.
		7. Car 클래스를 상속받아 ElectricCar를 만들고 __init__ 생성자에 'battery_type' 변수를 추가한다.

	※ 객체지향 프로그래밍의 장점과 단점을 알아보세요.
		객체지향 프로그래밍은 프로그램을 유연하고 변경이 용이하게 만들기 때문에 대규모 소프트웨어 개발에 많이 사용된다.
		또한 프로그래밍을 더 배우기 쉽게 하고 소프트웨어 개발과 보수를 간편하게 하며, 보다 직관적인 코드 분석을 가능하게 하는 장점을 갖고 있다.
		그러나 지나친 프로그램의 객체화 경향은 실제 세께의 모습을 그대로 반영하지 못한다는 비판을 받기도 한다.
		참고 위키백과 : https://ko.wikipedia.org/wiki/객체_지향_프로그래밍

	※ 학습정리
		- class 키워드로 클래스를 작성
			-> 클래스의 네이밍 컨벤션(Naming Convention)은 파스칼 표기법을 사용한다.
					예) Person, MyCar, BeautifulSoup

// ####################### 16교시 종료 ####################### //


// ####################### 17교시 시작 ####################### //
※ 엑셀파일 다루기
	- 엑셀파일을 다루는 모듈의 종류를 알아본다.
	- openpyxl 모듈을 사용하여 엑셀의 데이터를 읽고 쓰기를 수행한다.

※ 엑셀 문서 구조
	1. 엑셀 문서, Excel Documents
		워크북은 하나 이상의 워크시트로 구성됨
		현재 사용중인 (화면에 노출된) 워크시트를 액티브 시트라고 함

	1. 엑셀 지원 파이썬 모듈
		- xlwt
		- OpenPyXl http://openpyxl.readthedocs.org/
		- XlsxWriter
		- PyExcelerate

	2. openpyxl 모듈
		- 로컬에 엑셀 프로그램이 설치되어 있지 않아도 엑셀파일 생성과 읽기가 가능
		- 대용량 지원, 이미지 지원등
		- pip install openpyxl (openpyxl과 관련 모듈이 설치)

	1. 엑셀문서(워크북) 열기
		1.1. 워크시트 접근
			- 워크시트 목록 리스트로 변환
			- 액티브 워크시트 반환
				>>> import openpyxl
				>>> wb = openpyxl.load_workbook('example.xlsx')
				>>> wb.get_sheet_names()
					['Sheet1', 'Sheet2', 'Sheet3']
				>>> sheet = wb.get_sheet_by_name('Sheet3')
				>>> sheet.title
					'Sheet3'
				>>> another_sheet = wb.active

		1.2. 셀에 접근
			>>> sheet = wb.get_sheet_by_name('Sheet1')
			>>> sheet['A1']
				<Cell Sheet1.A1>
			>>> c = sheet['B1']
			>>> c.value
				'park.name'
			>>> 'Cell ' + c.coordinate + ' is ' + c.value
				'Cell B1 is park.name'
			>>> sheet['A45'].value
				44

		1.3. cell() 함수 : 키워드 파라미터 사용
			>>> sheet.cell(row=1, column=2)
				<Cell Sheet1.B1>
			>>> sheet.cell(row=1, column=2).value
				'Apples'
			>>> for i in range(1, 8, 2):
				print(i, sheet.cell(row=i, column=2).value)

			- 마지막 셀 (로우) : sheet.max_row
			- 마지막 셀 (컬럼) : sheet.max_column

		2. 여러 셀 접근하기
			>>> cell_range = sheet['A1':'C2']
			>>> colC = sheet['C']
			>>> col_range = sheet['C:D']
			>>> row10 = sheet[10]
			>>> row_range = sheet[5:10]

			- 전체 컬럼과 로우에 접근하는 코드
				>>> for col_cell in colC:
					... print(col_cell.value)

				>>> for col in col_range:
					... for cell in col:
					...		print(cell.value)
					...	print('')

				>>> for col_cell in colC:
				...		print(col_cell.value)

				>>> for row in row_range:
				...		for cell in row:
				...			print(cell.value)
				...		print('')

		3. 엑셀 문서 만들고 저장하기
			3.1. openpyxl.Workbook() : 워크북 생성
				- 워크북이 생성되면 최소 1개의 워크시트가 같이 생성된다.

			3.2. save('pyauto.xlsx') : 워크북 저장
				>>> from openpyxl import Workbook
				>>> wb = Workbook()
				>>> wb.sheetnames
					['Sheet']
				>>> sheet = wb.active
				>>> sheet.title
					'Sheet'
				>>> sheet.title = '파이썬 업무 자동화'
				>>> sheet.title
					'파이썬 업무 자동화'
				>>> wb.create_sheet('sheet2')			# 마지막에 추가
				>>> wb.create_sheet('sheet3', 1)	# 해당 위치에 추가
				>>> wb.save('pyauto.xlsx')				# 워크북 저장

		4. 셀을 접근할 때와 유사하다.
			- sheet['A1']																		# A1 셀의 값 읽기
			- sheet['A1'] = 'hello'													# A1 셀에 값 쓰기
			- sheet.cell[row=1, column=1]										# A1 센의 값 읽기
			- sheet.cell(row=1, column=1, value='world')		# A1 셀의 값 쓰기

		5. 엑셀 쓰기 : 수식 (formulas)
			>>> sheet['B9']	= '=SUM(B1:B8)'

			>>> import openpyxl
			>>> wb = openpyxl.Workbook()
			>>> sheet = wb.active
			>>> sheet['A1'] = 200
			>>> sheet['A2'] = 300
			>>> sheet['A3'] = '=SUM(A1:A2)'
			>>> wb.save('writeFormula.xlsx')

		6. 엑셀 쓰기 : 수식(formulas)
			- merge_cell() 함수를 사용하여 셀 합치기
				>>> import openpyxl
				>>> wb = openpyxl.Workbook()
				>>> sheet = wb.active
				>>> sheet.merge_cells('A1:D3')
				>>> sheet['A1'] = 'Twelve cells merged'
					'together.'
				>>> sheet.merge_cells('C5:D5')
				>>> sheet['C5'] = 'Two merged cells.'
				>>> wb.save('merged.xlsx')

		9. 연습문제
			9.1. example.xlsx 파일을 읽어서 텍스트 파일로 저장
				- 메이저리그 야구 구장 목록 엑셀파일에서 구장의 위치가 미국이 아닌 다른 국가에 있는 목록을 조회
				- 해당 데이터를 park_outside_us.txt 파일로 저장

		99. 학습정리
			- 엑셀은 workbook, worksheet(s) 그리고 cell로 구성된다.
			- openpyxl 모듈을 사용하면 엑셀파일을 만든고 데이터를 쓰고 읽을 수 있다.

// ####################### 17교시 종료 ####################### //

// ####################### 18교시 시작 ####################### //
※ CSV 파일 다루기
	- CSV 파일을 읽어 파이썬 리스트로 저장한다.
	- CSV 파일을 읽어 파이썬 딕셔너리로 저장한다.
	- 리스트 데이터를 CSV 파일로 저장한다.

	1. 구조화된 텍스트파일
		1.1. 프로그램에서 데이터를 저장할 떄나, 다른 프로그램으로 보낼 떄 사용
			- 탭('\t'), 콤마(','), 수직 바('|')와 같은 문자를 구분자 (separate, delimeter)로 사용
			- 태그를 '<' 와 '>'로 둘러싼다. - XML과 HTML이 있다.
			- 구두점을 사용한다. - JSON
			- 들여쓰기를 사용한다. - YAML (YAML Ain't ML)
			- 기타 프로그램 설정 파일 같은 형식이 있다.

		1.2. 구분된(delimited file)은 스프레드 시트나 데이터베이스의 데이터 교환 형식
			- CSV (Comma Separated Value)
			- 콤마로 구분된 데이터를 라인단위로 읽어 리스트나 딕셔너리 같은 자료구조에 넣는다.
			- 파일의 운영체제에 따른 줄바꿈 문자
				> 리눅스/맥 : \n
				> 윈도우즈 : \r\n
			- 컬럼 이름이 첫 번째 라인에 올 수 있다.

		1.3. 엑셀과 CSV의 차이점
			- 값의 데이터 타입이 없다 = 모든 값은 문자열
			- 각 셀의 폰트나 컬러가 없다.
			- 워크시트가 없다 (하나의 워크시트만 존재)
			- 셀의 높이나 너비가 없다. 셀 병합도 없다.
			- 이미지나 차트를 포함할 수 없다.

		1.4. 파이썬에서 CSV 다루는 방식
			- CSV 파일을 읽어서 리스트나 딕셔너리 데이터 구조로 저장하여 처리
			- 리스트나 딕셔너리 데이터 구조를 CSV 파일로 저장

		1.5. 리스트 <---> CSV
			- 파이썬 리스트의 내용을 CSV 파일에 쓰기
			- CSV 파일의 내용을 읽어 파이썬 리스트로 저장하기

		1.6. 딕셔너리 <---> CSV
			- 파이썬 딕셔너리의 내용을 읽어 CSV 파일에 쓰기
			- CSV 파일의 내용을 읽어 파이썬 딕셔너리로 저장하기

	2. CSV 파일
		2.1. CSV 파일 -> 리스트로 로딩하기
			# a_list = []
			# f = open('filename.csv', 'r')
			# reader = csv.reader(f)
			# for row in reader:
			#   a_list.append(row)
			# f.close()

			# csv모듈을 사용하기 위해 import csv
			# 출력을 보기 좋게 하기 위해 pprint 모듈 사용
			with open('filename.csv', 'r') as f:
				reader = csv.reader(f)
				a_list = list(reader)

		2.2. 리스트 -> CSV 파일 (line by line)
			import csv

			with open('output.csv', 'w', newline='') as file:		# newline 코드는 window 모듈일때만 사용
				writer = csv.writer(file)
				writer.writerow(['spam', 'eggs', bacon', 'ham'])
				writer.writerow(['Hello, world!', 'eggs', 'bacon', 'ham'])
				writer.writerow([1, 2, 3.141592, 4])

		2.3. CSV 파일 -> 딕셔너리로 로딩
			with open('filename.csv', 'r') as file:
				reader = csv.DictReader(file)
				for row in reader:
					print(row)
					# print(row['park.key'], row['park.name'], row['park.alias'], row['city'], row['state'], row['country']

			2.3.1. OrderedDict 타입으로 딕셔너리 생성
				# python3 에서 OrderedDict로 봐뀜 (dictionary는 순서가 없음, OrderedDict는 순서가 있음)
				- OrderedDict([('park.key', 'VALUE1'),  ('park.name', 'VAVLUE2') ...
				- cf) {'park.key':'Value1', ..... , 'country':'US'}

		2.4. CSV 파일 -> CSV 파일 저장
			- 딕셔너리 구조에 따라 적절히 처리

	3. 연습문제
		3.1. baseballdataback 폴더에 있는 모든 CSV 파일의 헤더를 제거하고 다시 저장
			- 폴더 내의 모든 csv 파일을 탐색한다.
			- 각 CSV 파일을 읽는다.
			- CSV 파일의 첫 번째 로우를 제거하고 다른 파일로 저장한다.

	9. 관계형 데이터 베이스와 CSV의 유사점
		- CSV 파일은 데이터베이스 테이블로 임포트 될 수 있고, 반대로 가능하다.
		- CSV 파일은 관계형 데이터베이스의 테이블과 엑셀파일의 구조가 유사하기 떄문에 데이터를 옮길 때 중간 단계로 많이 사용한다.

	99. 학습정리
		1. CSV 파일의 내용을 읽어 파이썬 리스트와 딕셔너리로 저장할 수 있다.
			-> csv 모듈의 reader()를 사용하여 리스트로 변환
			-> DictReader()로 OrderedDict(순서있는 딕셔너리)로 변환
		2. writer()를 통해 CSV 파일을 작성한다.
			-> writerow() 함수를 사용하여 라인단위로 기록

// ####################### 18교시 종료 ####################### //

// ####################### 19교시 시작 ####################### //
※ 오픈 API과 JSON
	- 오픈API (웹상에서 사용하는...)
		오픈 API를 이해한다.

	- JSON 파일 포맷
		requests 모듈을 사용하여 API를 사용하고 결과 JSON에 대해 이해한다.

	1. 오픈 API
		1.1. API (Application Programming Interface)
			- 여러 애플리케이션 사이에서 간편한 인터페이스

		1.2. 오픈 API - 주로 웹 API 또는 API라고 함
			- HTTP를 통해 데이터를 요청하며 주로 XML 이나 JSON 형식으로 응답
			- 최근에는 JSON 방식의 응답을 하는 API가 빠르게 늘어나고 있음
			- 유용한 형식으로 정리된 데이터를 제공 받을 수 있음

		1.3. API 동작 방식
			1.3.1. 브라우저에서 API 요청
				- http://api.github.com/users/soongon, https://api.github.com/users/dchkang83
				- 응답은 JSON 형태로 반환 (Python의 Dictionary와 유사)

	2. JSON 포맷
		2.1. 데이터 교환의 표준 포맷 - JSON
			>> JSON은 키/값 쌍으로 된 컬렉션 형태, 파이썬 딕셔너리 리스트와 유사함
			[			# List
				{		# Dictionary
					'key' : 'value'
				},
				{

				}
			]

	3. JSON 요청 및 처리
		3.1. requests 모듈
			- HTTP 요청 클라이언트 모듈
			- 파이썬 내장 모듈인 urllib에 쉽고 편리하게 사용 가능
			- pip install requests 설치 후 사용

		3.2. requests 모듈로 JSON 요청 및 프린트 ( 참고 : http://jsonviewer.stack.hu )
			import reqeusts										# request 모듈 임포트 (서드파티 모듈)

			my_request = requests.get('url')	# URL을 파라미터로 requests.get() 호출

			menu_list = my_request.json()			# JSON 포맷으로 응답

			print(menu_list)

	4. 연습문제
		4.1. 네이버 검색 API 사용 실습
			- http://developers.naver.com 사이트로 이동 (네이버 로그인 필요)
			- 네이버 API 사용을 위해 애플리케이션 등록 수행		(인증)
			- 사용 API에서 검색 서비스 선택
			- '파이썬' 검색어로 검색해서 결과 JSON 확인

	5. 날씨 관련 오픈 API
		- 동네 예보 정보조회 서비스:
			https://www.data.go.kr/subMain.jsp#/sadfasdfasfadsdfs등등
			공공데이터에서 제공하는 것으로 특별한 제약은 없을듯함

		- wunderground : https://www.wunderground.com/weather/api/d/pricing.html?MR=1
			yahoo날씨에서 사용하고 있음.

		- http://openweathermap.org/API
			40,000개 이상의 기상 관측소의 데이터 기반으로 업데이트 된 70,000도시의 현재 날씨 정보를 제공한다.

	※ 학습정리
		- 오픈 API는 줄여서 API라고 부르기도 한다.
		- json() 함수를 사용하여 JSON 포맷을 파이썬 데이터 타입으로 변환한다.
		- JSON포맷과 딕셔너리 구조는 상당히 유사하다.
		- requests 모듈을 사용하여 API를 쉽게 사용할 수 있다.
		- 네이버 오픈 API를 사용하기 위해서 가입하여 인증키를 확보한다.

// ####################### 19교시 종료 ####################### //

// ####################### 20교시 시작 ####################### //
※ 오픈 API 활용
	참고사이트 => ( http://docs.python-requests.org/en/master/ )
		Advanced Usage / Prepared Requests (링크)

	0. 네이버 오픈 API 사용 데모
		- 네이버 오픈 API중 get 방식으로 요청하는 검색 서비스를 사용한다.
		- post방식인 번역 서비스를 사용하여 영문을 한글로 번역한다.

	1. POST 방식으로 요청하는 네이버 API를 이용
		- 기계번역 API
			: 영어를 한글로 번역하기

	2. requests 모듈로 POST 요청하기
		2.1. 요청 객체를 미리 만들어둔다.
			- req = Request('POST', url, data=payload, headers=headers)
			- prepped = req.prepare()

		2.2. 세션객체를 통해 요청을 수행한다.
			- s = Session()
			- res = s.send(perpped)

	3. 네이버 기계번역 API를 이용해서 번역 수행
		3.1. 영어로 된 테스트 파일을 읽는다.
		3.2. 텍스트 파일을 라인단위로 읽어 기계번역 API를 호출하여 번역을 수행한다.
		3.3. 번역된 텍스트를 다시 파을을 저장한다.
			- 번역된 텍스트를 엑셀에 저장한다.

	9. 파이썬에서 API 서버 만들기
		웹 서버 어플리케이션을 지원하는 환경이면 API서버를 만들수 있다.
		각 언어별로 서버 어플리케이션을 지원하는데 자바는 스프링 프레임워크를 이용해서 가능하고,
		자바스크립트는 노드로 가능하고,
		파이썬은 Django프레임워크나, Flask프레임워크로 작성 가능하다.

	※ 학습정리
		- GET 방식의 요청은 requests 모듈의 get() 함수를 사용한다.
		- POST 방식의 요청은 requests 모듈의 Request 객체를 사용한다.
			-> 준비된 요청을 만들어 세션을 통해 요청을 전달한다.
// ####################### 20교시 종료 ####################### //

// ####################### 21교시 시작 ####################### //
※ Web Scraping1 (웹 스크레이핑1)
	- BeautifulSoup4 모듈을 사용하여 웹 페이지의 데이터를 추출한다.
	- 웹브라우저 개발자 도구를 사용하여 데이터를 추출하는 방법을 이해한다.

	※ 스크래퍼(Scraper)란?

	※ 웹 스크레이퍼
		1. 도메인 주소를 가지고 HTML 데이터를 가져옴
		2. 데이터를 파싱해 원하는 정보를 얻음
		3. 원하는 정보를 저장함
		4. 필요하다면 다른 페이지에서도 이 작업을 반복함

	1. 필요한 모듈들
		- requests
		- BeautifulSoup4	(JAVA에서는 JSOUP)
		- lxml

	2. 웹 사이트에 연결 및 요청 : HTML 결과를 얻어옴
		2.1. requests 모듈 사용 ( pip install reqeusts )
			- http://docs.python-requests.org/en/master/
				import requests

				res = requests.get('http://url.com')
				print(res)

		2.2. 원하는 컨텐츠를 뽑아낸다.
			- res.headers
			- res.encoding
			- res.text
			- res.json()

		2.3. 컨텐츠를 저장한다.

	3. BeautifulSoup 소개
		3.1. HTML (XML)을 파싱하게 좋게 파이썬 객체로 돌려준다.
			- 잘못된 HTML을 수정하여 반환해줌

		3.2. 설치
			- pip install beautifulsoup4
			- Beautiful Soup 설치 검즘
				from bs4 import BeautifulSoup (파이썬 콘솔에서 확인)
			- https://www.crummy.com/software/BeautifulSoup/bs4/doc/

		3.3. BeautifulSoup 객체 생성
			helloworld = '<p>Hello World</p>'
			soup_string = BeautifulSoup(helloworld)

			# soup_string = BeautifulSoup(helloworld, 'html.parser')	# html.parser 보다 lxml이 더 빠르다.

			cf.html.parser vs lxml
				- lxml 모듈을 사용하기 위해서는 먼저 lxml 모듈을 설치해야 한다. ( pip install lxml )

		3.4. Tag 객체
			>>> res = requests.get('http://url.com')
			>>> soup = BeautifulSoup(res.text, 'lxml')
			>>> a_tag = soup.a
			>>> type(a_tag)
				<class 'bs4.element.Tag'>
			>>> print(a_tag.prettify())

		3.5. NavigableString 객체
			3.5.1. .string vs .text
				ex)
					<td>some text</td>
					<td></td>
					<td>
						<p> more text</p>
					</td>
					<td>
						even
						<p>more text</p>
					</td>

				- .string : td 태그 4개 모두 리턴
					>> some text None more text None
				- .text : 모든 글자를 리턴
					>> some text more text even more text

		3.6. 원하는 데이터 추출하기
			- 웹 페이지에서 특정 데이터를 추출하기 위해서는 해당 데이터를 포함하는 태그를 찾아야 한다.

			# @@@ 크롬 개발자 도구
				Copy > Copy Selector
				Copy > Copy XPath

		3.7. 웹 스크레이핑의 법적인 문제
			크롤링이 합법이냐에 대한 문제는 2000년 초부터 꾸준히 법적 공방이 이루어져 왔다.
			각 웹 사이트는 robots.txt라는 파일을 루트위치에 두어 검색엔진이 크롤링을 하지 않기 바라는 부분을 표시하고 엑세스 권한을 알려준다.
			아마존 예시 : https://www.amazon.com/robots.txt
			하지만 robots.txt는 지침에 지나지 않고 크롤러 동작을 강요할 수 없다.
			따라서 웹사이트 입장에서는 웹페이지를 제작할 떄 민감한 정보는 크롤러가 애초에 접근하지 못하게 하는것이 좋다.

		※ 학습정리
			- BeautifulSoup을 사용하면 HTML을 Well-formed 하게 수정해 준다.
			- lxml 모듈을 사용하여 파싱할 것을 권장한다.
			- 웹브라우저의 개발자 도구를 사용하여 특정 태그에 접근하는 방법을 획득한다.
// ####################### 21교시 종료 ####################### //


// ####################### 22교시 시작 ####################### //
※ 웹 스크레이핑 2
	학습내용
		1. 웹 스크레이핑 데모
		2. 간단한 웹 크롤링 데모
	학습목표
		- find() 함수와 find_all() 함수를 사용하여 웹 스크레이핑을 수행한다.
		- selet() 함수를 사용하여 웹 스크레이핑을 수행한다.

	1. 원하는 데이터 추출하기
		- 웹 페이지에서 특정 데이터를 추출하기 위해서는 해당 데이터를 포함하는 태그를 찾아야 한다.

	2. find()와 find_all()
		2.1. BeautifulSoup에서 가장 자주 쓰이는 함수
		2.2. HTML 페이지에서 원하는 태그를 다양한 속서에 따라 쉽게 필터링 할 수 있음
			- find(tag, Attributes)				# tag.find('div')
			- find_all(tag, Attributes)		# tag.find_all('a', href='link3')
			- find(Attributes), find_all(attributes)
			- find(class_='box')					# CSS 클래스명으로 찾기

		2.3. 정규식으로 찾기
			- find(re.compile('^b'))							# b로 시작되는 첫 번째 태그
			- find_all(re.compile('t'))						# t를 포함한 모든 태그
			- find_all(href=re.compile('[\w]{3}']

	3. 연습문제
		3.1. http://www.pythonscraping.com/pages/page3.html
			- 페이지 내의 테이블의 내용을 CSV 파일로 저장

	4. CSS 셀렉터로 찾기
		- soup.select("head > title")		# 결과 LIST로 반환된다.
		- soup.select(".sister")													# 클래스명으로 찾기
		- soup.select("a#link2")													# 아이디로 찾기
		- soup.select('a[href^="http://example.com/"]')		# 특정문자열로 시작		^ 시작하는
		- soup.select('a[href$="title"]')									# 특정문자열로 끝남		$ 끝나는

	5. 연습문제
		5.1. http://example.webscraping.com/
			- 사이트의 모든 내용을 엑셀로 저장

			- 크롤링 (타고 -> 타고 -> 들어가는것)
				10개 국가, 각각 25페이지 (250페이지) 등.. 국가정보 클릭된 정보 스크래핑하는것

	9. 웹 크롤링 과 웹 스크레이핑의 차이점
		크롤링이 기본적으로 모든 데이터를 가져오는거라면 웹 스크래핑은 크롤링으로 생각하기도 하고,
		짧은 범위로는 특정 정보만 추출하는 걸 의미한다.
		참고로 다음은 웹크롤링에 대한 정의이다.
		웹 크롤러가 하는 작업을 웹 크롤링(web crawling) 혹은 스파이더링(spidering)이라 부른다.
		검색 엔진과 같은 여러 사이트에서는 데이터의 최신 상태 유지를 위해 웹 크롤링 한다.
		웹 크롤러는 대체로 방문한 사이트의 모든 페이지의 복사본을 생성하는 데 사용되며, 검색 엔진은
		이렇게 생성된 페이지를 보다 빠른 검색을 위해 인덱싱한다.
		또한 크롤러는 링크 체크나 HTML 코드 검증과 같은 웹 사이트의 자동 유지 관리 작업을 위해
		사용되기도 하며, 자동 이메일 수집과 같은 웹 페이지의 특정 형태의 정보를 수집하는 데도 사용된다.

	※ 학습정리
		- find(), find_all() 함수를 이용하면 태그명과 속성명으로 태그를 추출할 수 있다.
		- 태그명과 속성명에는 정규식 문법을 사용할 수 있다.
		- select() 함수는 CSS 셀렉터 문법을 사용하여 태그를 추출할 수 있다.

// ####################### 22교시 종료 ####################### //

// ####################### 23교시 시작 ####################### //
※ 날짜 다루기, 스케줄링, 프로세스
	1. 날짜와 시간 다루기
	2. 스케쥴링
	3. 프로세스 실행
		- time, datetime 모듈을 사용하여 날짜와 시간을 다룬다.
		- subprocess 모듈로 다른 프로그램을 실행한다.

	1. time 모듈 (1970.01.01 부터 0 -> float)	epoch time (1970.01.01 - 0)
		- 날짜와 시간을 표현하는 형식은 너무도 다양함
		- time 모듈 : 절대시간(epoch 타임)을 다루는 모듈
		- datetime모듈 : 시간을 보기 좋게 표현하는 방식에 대한 모듈

	2. time.time() 함수
		- 1970.01.01. 00:00:00		-> 에포크 타임스탬프
		- 에포크로 부터의 경과시간을 숫자(float타입)로 표시
		- round(time.time())으로 소숫점을 없애서 사용가능

		- now = time.time()
		- time.ctime(now)
		- time.localtime(now)
		- time.gmtime(now)

	3. 시간끼리 비교 가능
		- time.time()의 숫자로 비교 (즉 비래가 과거보다 크다)

	4. 실행시간 계산 예제
		import time

		def calc_prod():
			# Calculate the product of the first 100,000 numbers.
			product = 1
			for i in range(1, 100000):
				product = product * i
			return product

		def main():
			start = time.time()
			prod = calc_prod()
			end = time.time()
			print('The result is {0}'.format(len(str(prod))))
			print('Took {0} seconds to calculate.'.format(end - start))

	5. time.sleep() 함수
		5.1. 프로그램을 잠시 중지할 필요가 있을 때 사용
			- time.sleep(second) : 해당 second(초) 만큼 프로그램이 일시 중지
			- KeyboardInterrupt 예외를 처리해서 Ctrl+C 키를 눌렀을 떄 종료 가능
				>>> for i in range(30):
				...		time.sleep(1)
				...		print(i)

	6. datetime 모듈의 주요 4개 객체
		- date : 년, 월, 일
		- time : 시, 분, 초, 마이크로초
		- datetime : 날짜와 시간
		- timedelta : 날짜 와 / 또는 시간 간격

		6.1. date
			- 년, 월, 일을 지정하여 date 객체를 만들 수 있다.
			- 각 값은 속성으로 접근할 수 있다.
			>>> from datetime import date
			>>> white = date(2017, 3, 14)
			>>> white
				datetime.date(2017, 3, 14)
			>>> white.month
				3
			>>> white.day
				14
			>>> white.year
				2017
			>>> white.isoformat()
				'2017-03-14'

		6.2. time
			- 하루의 시간을 나타내는 데 사용한다.
			- 인자를 입력하지 않으면 0으로 간주한다.
			>>> from datetime import time
			>>> bedtime = time(22, 35, 45)
			>>> bedtime
				datetime.time(22, 35, 45)
			>>> bedtime.hour
				22
			>>> bedtime.minute
				35
			>>> bedtime.second
				45

		6.3. datetime
			- 날짜와 시간을 모두 포함한다.
				>>> from datetime import datetime
				>>> some_day = datetime(2050, 1, 2, 3, 4, 5, 6)

			- iso 포맷 메소드
				>>> some_day.isoformat()

			- now() 메소드로 현재 날짜를 얻을 수 있다.
				>>> now = datetime.now()

		6.4. timedelta 를 통해 시간 간격을 계산할 수 있다.
			- 현재부터 1000일 후
				>>> now = datetime.now()
				>>> dday = timedelta(days=1000)
				>>> theday = now + dday

	7. 특정 날짜까지 프로그램 중지
		import datetime
		import time

		wakeup_time = datetime.datetime(2020, 10, 31, 0, 0, 0)
		while datetime.datetime.now() < wakeup_time:
			time.sleep(1)		# 매 초마다 체크해서 wakeup_time이 되는지 체크

	8. datetime 객체를 문자로 바꾸기
		- strftime() 함수로 보기 좋은 포맷으로 변경
			>>> wc8 = datetime.datetime(2002, 6, 22, 15, 30, 0)
			>>> wc8.strftime('%Y/%m/%d %H:%M:%S')		# %H : 24시간
				'2002/06/22 15:30:00'
			>>> wc8.strftime('%I:%M %P')						# %I : 12시간
				'03:30 PM'
			>>> wc8.strftime("%B of '%y")						# %B : 현재월의 줄임말, %y : 2자리
				"June of '02"

	9. 다른 프로그램 실행
		9.1 subprocess 모듈 사용
			- subprocess.Popen() : 어플리케이션 실행
				>>> import subprocess
				>>> subprocess.Popen('C:\\Windows\\System32\\calc.exe')
				<subprocess.Popen object at 0X00000000055A58>

			- OS가 우분투일 떄
				>>> import subprocess
				>>> subprocess.Popen('/usr/bin/gnome-calculator')
				<subprocess.Popen object at 0X7fas12as29>

			- 다른 파이썬 스크립트 실행
				>>> import subprocess
				>>> subprocess.Popen(['C:\\python34\\python.exe', 'hello.py'])
				<subprocess.Popen object at 0X00000001231CF28>


			- 기본 프로그램으로 파일 열기
				>>> import subprocess
				>>> subprocess.Popen(['start', 'hello.txt'], shell=True)	# start : 기본프로그램을 실행해 달라
				<subprocess.Popen object at 0X00000000055A58>

			- 다른 파이썬 스크립트 실행
				>>> import subprocess
				>>> subprocess.Popen(['pythone.exe', 'hello.py'])
				<subprocess.Popen object at 0X00000000055A58>

	00. 연습문제
		1. 타이머 프로그램 : 특정 시간 이후에 알람이 울리는 프로그램 작성
			1.1. 카운트다운 코드
			1.2. 사운드 파일 실행

	※ 절대시간 epoch에 대해서 알아보세요.
		유닉스 시간 (영어:Unix time)은 시각을 나타내는 방식이다.
		POSIX 시간이나 Epoch 시간이라고 부르기도 한다.
		1970년 1월 1일 00:00:00 협정 세계시(UTC) 부터의 경과 시간을 초로 환산하여 정수로
		나타낸 것이다. 유닉스 시간에서 윤초는 무시된다.
		유닉스 계열 운영 체제나 여러 다른 운영 체제, 그리고 파일 형식들에서 사용된다.
		윤초 처리 방식 때문에 시간을 선형으로 표현하지 못하며, 협정 세계시의 윤초를 표현할 수 없다.
		유닉스 시간은 대다수의 유닉스 운영 체제에서 date +%s를 명령행에 입력하여 확인할 수 있다.

	※ 학습정리
		1. date 모듈 - epoch 기반 시간을 다룬다.
		2. datetime모듈 - 시간을 다루기 쉽게 처리해주는 모듈
		3. subprocess.Popen() - 다른 프로세스를 실행해 준다.
// ####################### 23교시 종료 ####################### //

// ####################### 24교시 시작 ####################### //
※ 메일 보내기
	1. SMTP 서버 접속
	2. 메일 메세지 보내기
		- smtplib 모듈을 사용해서 SMTP 서버에 접속한다.
		- email.message.EmailMessage 객체를 사용해서 메일 메세지를 만든다.

	※ SMTP : 메일 보내기
		가. smtplib 사용
			1. SMTP 서버 접속
				>>> smtp = smtplib.SMTP('smtp.gmail.com', 587)
				>>> type(smtp)
				<class 'smtplib.SMTP'>
				>>> smtp = smtplib.SMTP_SSL('smtp.gmail.com', 465)	# SSL일 떄 설정

			2. SMTP에게 "Hello" 메시지 보내기
				>>> smtp.ehlo()
					(250, b'mx.google.com at your service. [216.172.148.131]\nSIZE
					231232234\ ....)

			3. TLS 암호화 시작
				>>> smtp.starttls()
					(220, b'2.0.....)
				SMTP_SSL로 설정되었을 떄는 사용하지 않는다.

			4. SMTP 서버에 로그인
				>>> smtp.login('my_email.address@gmail.com ', ' MY_SECRET_PASSWORD ')
					(235, b'2.7.0 Accepted')

			5. 이메일 보내기
				>>> smtp.send_message(msg)	# EmailMessage 객체 msg 사용

			6. SMTP 서버 접속 끊기
				>>> smtp.quit()
					(221, b'2.0.0 closing connection ....)

		※ 메일 보내기 함수 : send_message()
			- EmailMessage 타입의 객체를 사용
				from email.message import EmailMessage
				msg = EmailMessage()

			- 제목과 from, to 각각 설정
				msg['Subject'] = '제목을 적습니다.'
				msg['From'] = 'sender@mail_address.com'
				msg['To'] = 'recipient1@mail_address.com, recipient2@mail.com'
				msg.set_content('여기에 본문 내용을 적습니다. 여러 라인도 가능합니다.')		# multiline은 '''  ''' 으로 처리 가능

			- send_message(msg)함수로 메일 보내기

				import smtplib
				smtp = smtplib.SMTP_SSL('smtp.gmail.com', 465)

				smtp.ehlo()	# 테스트 hello

				smtp.login('dchkang83@gmail.com', 'aasfadsfs')
				...
				smtp.quit()	# 접속 끊기

		※ 연습문제
			1. 엑셀에서 데이터 읽기
			2. 저번 달에 회비를 내지 않은 회원 찾기
			3. 이메일 주소를 통해 개별로 리마인드 메일 보내기

		바이트 스트링을 스트링으로 바꾸는 코드는?
			b'hello'.encode('utf-8')

	※ 학습정리
		1. 메일보내기 절차
			- SMTP() 또는 SMTP_SSL()로 접속
			- ehlo() - 서버에게 Hello메세지 보내기
			- login(id, password) 함수로 로그인
			- send_message() 이메일 보내기
			- quit() 접속 끊기

		2. 메일 메세지 만들기
			- EmailMessage

// ####################### 24교시 종료 ####################### //

// ####################### 25교시 시작 ####################### //
※ 메일 받기
	가. imap 서버 연결
		- imap 메일서버에 대해 이해하고, 구글 지메일 imap 서버에 접속한다.
		- 메일을 받는 프로토콜은 IMAP, POP3가 있다.

	나. 메일함에 접근해서 메일 가져오기
		- 메일함에 접근하여 메일을 검색, 패치 할 수 있다.


	※ IMAP : 이메일 받기와 지우기
		1. imaplib와 email 두 개의 모듈을 사용
			1.1. IMAP 서버에 로그인 하고, 이메일을 검색하고, 가져와서 메시지를 읽는다.
				1.1.1. IMAP 서버에 접속
					>>> import imaplib
					>>> imap = imaplib.IMAP4_SSL('imap.gmail.com')

				1.1.2. IMAP 서버에 로그인
					>>> imap.login('soongon@gmail.com', 'PASSWORD')
						(OK, ....)

				1.1.3. INBOX 선택
					>>> imap.select('inbox')
						(OK, [b'3'])	# 메일이 3통 있음		b : byte string

				1.1.4. 이메일 검색
					>>> result, data = imap.uid('search', None, "ALL")									# ALL 전체 조회
					>>> latest_email_uid = data[0].split()[-1]													# -1로 가장 마지막(최근에 받은 메일)
					>>> result, data = imap.uid('fetch', latest_email_uid, '(REF822)')	# uid에 대한 이메일 내용
					>>> raw_email = data[0][1]

				1.1.5. Raw Email 파싱하기
					>>> import email
					>>> email_message = email.message_from_string(raw_email.decode('utf-8'))		# raw_email.decode('utf-8') : byte가 string 으로 변경된다.
					>>> email_message['To']
						'aasdfsdf@gmail.com'
					>>> email.utils.parseaddr(email_message['From'])
						('=?UTF8?B'6sdasd?=', 'aasdfsdf@gmail.com')


				1.1.6. 이메일 본문 내용 확인
					>>> if email_message.is_multipart():
						...
							for p in email_message.get_payload():
								print(p.get_payload())
						...

				1.1.7. 로그아웃
					>>> imap.close()
					>>> imap.logout()

		2. 이메일 지우기
			>>> imap.uid('store', '65334', '+FLAGS', '(\\Deleted)')			# 65334은 UID
				('OK', [b'2.......)
			>>> imap.expunge()
				('OK', [b'2'])	# 2통 남았다

		3. IMAP : search() 함수
			3.1. HEADER로 찾기
				- imap.uid('search', None, '(HEADER Subject "instruction")')
				- imap.uid('search', None, '(HEADER From "soongon@gmail.com"')

			3.2. 특정 날짜 이후로 찾기 : SENTSINCE
				>>> import datetime
				>>> date = (datetime.date.today() - datetime.timedelta(1)).strftime("%Y-%m-%d")
				>>> result, data = mail.uid('search', None, '(SENTSINCE {})'.format(date))

	9. 연습문제 : 이메일로 컴퓨터 원격 조작하기
		- 토렌트 파일의 이름을 이메일로 보내면
		- 주기적으로 메일을 체크하는 파이썬 데몬이 메일을 읽어
		- 토렌트를 자동으로 다운로드하는 프로그램 작성
		9.1. 매 15분마다 메일을 체크하는 데몬 작성
		9.2. 해당 메일이 있으면 토렌트 파일명을 가져온다.
		9.3. Popen()로 토렌트를 실행시킨다.
			qbProcess = subprocess.Popen(
				['C:\\Program Files (x86)\\gBittorrent\\ qbittorrent.exe'
					'shakespeare_complete_works.torrent'])
		9.4. 작업 완료 후 완료 메일을 보낸다.

	※ 학습정리
		1. imap 서버에 접속
			- 로그인 후 메일함 선택 ('inbox')
			- search : 메일함 검색
			- fetch : uid를 통해 메일 가져오기

		2. 로우 이메일 파싱하기
			- email 모듈 사용

// ####################### 25교시 종료 ####################### //
